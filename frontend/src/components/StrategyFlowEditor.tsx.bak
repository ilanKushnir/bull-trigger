import {
    ArrowPathIcon,
    CpuChipIcon as BrainIcon,
    ChatBubbleLeftIcon,
    CheckIcon,
    PencilIcon as EditIcon,
    GlobeAltIcon as GlobeIcon,
    InformationCircleIcon,
    PlayIcon,
    PlusIcon,
    BeakerIcon as TestTubeIcon,
    TrashIcon,
    XMarkIcon
} from '@heroicons/react/24/outline';
import { useCallback, useEffect, useState } from 'react';
import ReactFlow, {
    addEdge,
    Background,
    BackgroundVariant,
    Connection,
    ConnectionLineType,
    Controls,
    Edge,
    Handle,
    Node,
    NodeTypes,
    Position,
    useEdgesState,
    useNodesState
} from 'reactflow';
import 'reactflow/dist/style.css';
import { Strategy, useApi } from '../services/websocketService';
import { Button } from './ui/button';
import { Card, CardContent, CardHeader, CardTitle } from './ui/card';
import { Input } from './ui/input';
import { Label } from './ui/label';
import { Textarea } from './ui/textarea';

interface StrategyFlowEditorProps {
  strategyId: number;
  onClose: () => void;
  onRefetch?: () => Promise<void>;
}

interface ApiCall {
  id?: number;
  name: string;
  url: string;
  method: string;
  headers?: string;
  body?: string;
  jsonPath?: string;
  outputVariable: string;
  orderIndex: number;
  enabled: boolean;
  castToNumber?: boolean; // Cast extracted value to number
}

interface ModelCall {
  id?: number;
  name: string;
  modelTier: 'cheap' | 'deep';
  systemPrompt?: string;
  userPrompt: string;
  includeApiData: boolean;
  outputVariable: string;
  orderIndex: number;
  enabled: boolean;
}

interface ConditionNode {
  id?: number;
  name: string;
  conditionType: 'api_result' | 'model_response' | 'variable_value';
  leftOperand: string;
  operator: '==' | '!=' | '>' | '<' | '>=' | '<=' | 'contains' | 'startsWith' | 'endsWith';
  rightOperand: string;
  trueOutputVariable?: string;
  falseOutputVariable?: string;
  orderIndex: number;
  enabled: boolean;
}

interface StrategyTriggerNode {
  id?: number;
  name: string;
  targetStrategyId: number;
  conditionVariable?: string;
  passVariables?: string[];
  waitForCompletion: boolean;
  outputVariable?: string;
  orderIndex: number;
  enabled: boolean;
}

interface TelegramMessageNode {
  id?: number;
  name: string;
  chatId: string;
  messageTemplate: string;
  includeApiData: boolean;
  onlyIfVariable?: string;
  messageType: 'info' | 'success' | 'warning' | 'error';
  parseMode?: 'Markdown' | 'HTML' | 'none';
  orderIndex: number;
  enabled: boolean;
}

// Custom Node Components
const StartNode = ({ data }: { data: any }) => {
  return (
    <div 
      className="bg-green-600 border-2 border-green-500 rounded-lg p-3 text-white w-[200px] h-[80px] cursor-pointer hover:bg-green-700 transition-colors flex flex-col justify-center"
      onClick={() => data.onEdit?.(data)}
      title={`${data.name}\n${data.description || 'Strategy begins here'}\n${data.cron ? `Schedule: ${data.cron}` : 'Manual trigger only'}`}
    >
      <div className="flex items-center space-x-2">
        <PlayIcon className="w-4 h-4 flex-shrink-0" />
        <div className="flex-1 min-w-0">
          <div className="font-semibold text-sm truncate">START</div>
          <div className="text-xs text-green-200 truncate">{data.name}</div>
        </div>
      </div>
      <Handle
        type="source"
        position={Position.Right}
        className="w-3 h-3 bg-green-400 border-2 border-green-300"
      />
    </div>
  );
};

const ApiCallNode = ({ data }: { data: any }) => {
  return (
    <div 
      className="bg-blue-600 border-2 border-blue-500 rounded-lg p-3 text-white w-[200px] h-[80px] cursor-pointer hover:bg-blue-700 transition-colors flex flex-col justify-center"
      onClick={() => data.onEdit?.(data)}
      title={`${data.name}\n${data.method} ${data.url}\nOutput: ${data.outputVariable}\n${data.enabled ? 'Enabled' : 'Disabled'}`}
    >
      <Handle
        type="target"
        position={Position.Left}
        className="w-3 h-3 bg-blue-400 border-2 border-blue-300"
      />
      <div className="flex items-center space-x-2">
        <GlobeIcon className="w-4 h-4 flex-shrink-0" />
        <div className="flex-1 min-w-0">
          <div className="font-medium text-sm truncate">{data.name}</div>
          <div className="text-xs text-blue-200 truncate">{data.method}</div>
        </div>
        <div className={`w-2 h-2 rounded-full flex-shrink-0 ${data.enabled ? 'bg-green-400' : 'bg-red-400'}`} />
      </div>
      <Handle
        type="source"
        position={Position.Right}
        className="w-3 h-3 bg-blue-400 border-2 border-blue-300"
      />
    </div>
  );
};

const ModelCallNode = ({ data }: { data: any }) => {
  return (
    <div 
      className="bg-purple-600 border-2 border-purple-500 rounded-lg p-3 text-white w-[200px] h-[80px] cursor-pointer hover:bg-purple-700 transition-colors flex flex-col justify-center"
      onClick={() => data.onEdit?.(data)}
      title={`${data.name}\n${data.modelTier} model\n${data.includeApiData ? 'Includes API data' : 'Template only'}\nOutput: ${data.outputVariable}\n${data.enabled ? 'Enabled' : 'Disabled'}`}
    >
      <Handle
        type="target"
        position={Position.Left}
        className="w-3 h-3 bg-purple-400 border-2 border-purple-300"
      />
      <div className="flex items-center space-x-2">
        <BrainIcon className="w-4 h-4 flex-shrink-0" />
        <div className="flex-1 min-w-0">
          <div className="font-medium text-sm truncate">{data.name}</div>
          <div className="text-xs text-purple-200 truncate">{data.modelTier} model</div>
        </div>
        <div className={`w-2 h-2 rounded-full flex-shrink-0 ${data.enabled ? 'bg-green-400' : 'bg-red-400'}`} />
      </div>
      <Handle
        type="source"
        position={Position.Right}
        className="w-3 h-3 bg-purple-400 border-2 border-purple-300"
      />
    </div>
  );
};

const ConditionNode = ({ data }: { data: any }) => {
  return (
    <div 
      className="bg-yellow-600 border-2 border-yellow-500 rounded-lg p-3 text-white w-[200px] h-[80px] cursor-pointer hover:bg-yellow-700 transition-colors flex flex-col justify-center"
      onClick={() => data.onEdit?.(data)}
      title={`${data.name}\nCondition: ${data.leftOperand} ${data.operator} ${data.rightOperand}\nType: ${data.conditionType?.replace('_', ' ')}\n${data.enabled ? 'Enabled' : 'Disabled'}`}
    >
      <Handle
        type="target"
        position={Position.Left}
        className="w-3 h-3 bg-yellow-400 border-2 border-yellow-300"
      />
      <div className="flex items-center space-x-2">
        <InformationCircleIcon className="w-4 h-4 flex-shrink-0" />
        <div className="flex-1 min-w-0">
          <div className="font-medium text-sm truncate">{data.name}</div>
          <div className="text-xs text-yellow-200 truncate">Condition</div>
        </div>
        <div className={`w-2 h-2 rounded-full flex-shrink-0 ${data.enabled ? 'bg-green-400' : 'bg-red-400'}`} />
      </div>
      <Handle
        type="source"
        position={Position.Right}
        id="true"
        className="w-3 h-3 bg-green-400 border-2 border-green-300"
        style={{ top: '60%' }}
      />
      <Handle
        type="source"
        position={Position.Right}
        id="false"
        className="w-3 h-3 bg-red-400 border-2 border-red-300"
        style={{ top: '80%' }}
      />
    </div>
  );
};

const StrategyTriggerNode = ({ data }: { data: any }) => {
  return (
    <div 
      className="bg-orange-600 border-2 border-orange-500 rounded-lg p-3 text-white w-[200px] h-[80px] cursor-pointer hover:bg-orange-700 transition-colors flex flex-col justify-center"
      onClick={() => data.onEdit?.(data)}
      title={`${data.name}\nTarget: Strategy #${data.targetStrategyId}\n${data.waitForCompletion ? 'Wait for completion' : 'Fire & forget'}\n${data.conditionVariable ? `Condition: ${data.conditionVariable}` : 'Always trigger'}\n${data.enabled ? 'Enabled' : 'Disabled'}`}
    >
      <Handle
        type="target"
        position={Position.Left}
        className="w-3 h-3 bg-orange-400 border-2 border-orange-300"
      />
      <div className="flex items-center space-x-2">
        <ArrowPathIcon className="w-4 h-4 flex-shrink-0" />
        <div className="flex-1 min-w-0">
          <div className="font-medium text-sm truncate">{data.name}</div>
          <div className="text-xs text-orange-200 truncate">Trigger Strategy</div>
        </div>
        <div className={`w-2 h-2 rounded-full flex-shrink-0 ${data.enabled ? 'bg-green-400' : 'bg-red-400'}`} />
      </div>
      <Handle
        type="source"
        position={Position.Right}
        className="w-3 h-3 bg-orange-400 border-2 border-orange-300"
      />
    </div>
  );
};

const TelegramMessageNode = ({ data }: { data: any }) => {
  return (
    <div 
      className="bg-teal-600 border-2 border-teal-500 rounded-lg p-3 text-white w-[200px] h-[80px] cursor-pointer hover:bg-teal-700 transition-colors flex flex-col justify-center"
      onClick={() => data.onEdit?.(data)}
      title={`${data.name}\nChat: ${data.chatId}\nType: ${data.messageType} message\n${data.onlyIfVariable ? `Condition: ${data.onlyIfVariable}` : 'Always send'}\n${data.enabled ? 'Enabled' : 'Disabled'}`}
    >
      <Handle
        type="target"
        position={Position.Left}
        className="w-3 h-3 bg-teal-400 border-2 border-teal-300"
      />
      <div className="flex items-center space-x-2">
        <ChatBubbleLeftIcon className="w-4 h-4 flex-shrink-0" />
        <div className="flex-1 min-w-0">
          <div className="font-medium text-sm truncate">{data.name}</div>
          <div className="text-xs text-teal-200 truncate">Send to Telegram</div>
        </div>
        <div className={`w-2 h-2 rounded-full flex-shrink-0 ${data.enabled ? 'bg-green-400' : 'bg-red-400'}`} />
      </div>
      <Handle
        type="source"
        position={Position.Right}
        className="w-3 h-3 bg-teal-400 border-2 border-teal-300"
      />
    </div>
  );
};

const EndNode = ({ data }: { data: any }) => {
  return (
    <div 
      className="bg-red-700 border-2 border-red-600 rounded-lg p-3 text-white w-[200px] h-[80px] flex flex-col justify-center"
      title={`${data.name || 'End'}\n${data.description || 'Flow ends here'}`}
    >
      <Handle
        type="target"
        position={Position.Left}
        id="end-input"
        className="!bg-red-300 !border-red-600 !w-3 !h-3"
      />
      <div className="flex items-center space-x-2">
        <XMarkIcon className="w-4 h-4 text-red-100 flex-shrink-0" />
        <div className="flex-1 min-w-0">
          <div className="font-medium text-sm truncate">END</div>
          <div className="text-xs text-red-200 truncate">Flow ends here</div>
        </div>
      </div>
    </div>
  );
};

const nodeTypes: NodeTypes = {
  start: StartNode,
  apiCall: ApiCallNode,
  modelCall: ModelCallNode,
  condition: ConditionNode,
  strategyTrigger: StrategyTriggerNode,
  telegramMessage: TelegramMessageNode,
  end: EndNode,
};

// Add edge styles
const edgeOptions = {
  animated: true,
  style: { strokeWidth: 3 },
  type: 'default',
};

export default function StrategyFlowEditor({ strategyId, onClose, onRefetch }: StrategyFlowEditorProps) {
  const [apiCalls, setApiCalls] = useState<ApiCall[]>([]);
  const [modelCalls, setModelCalls] = useState<ModelCall[]>([]);
  const [conditionNodes, setConditionNodes] = useState<ConditionNode[]>([]);
  const [strategyTriggerNodes, setStrategyTriggerNodes] = useState<StrategyTriggerNode[]>([]);
  const [telegramMessageNodes, setTelegramMessageNodes] = useState<TelegramMessageNode[]>([]);
  const [loading, setLoading] = useState(true);
  const [editingApiCall, setEditingApiCall] = useState<ApiCall | null>(null);
  const [editingModelCall, setEditingModelCall] = useState<ModelCall | null>(null);
  const [editingConditionNode, setEditingConditionNode] = useState<ConditionNode | null>(null);
  const [editingStrategyTriggerNode, setEditingStrategyTriggerNode] = useState<StrategyTriggerNode | null>(null);
  const [editingTelegramMessageNode, setEditingTelegramMessageNode] = useState<TelegramMessageNode | null>(null);
  const [testResult, setTestResult] = useState<any>(null);
  const [testing, setTesting] = useState(false);
  const [executionLogs, setExecutionLogs] = useState<any[]>([]);
  const [executing, setExecuting] = useState(false);
  const [strategy, setStrategy] = useState<any>(null);
  const [editingStrategy, setEditingStrategy] = useState<any>(null);
  const [availableStrategies, setAvailableStrategies] = useState<Strategy[]>([]);
  const [availableVariables, setAvailableVariables] = useState<string[]>([]);
  
  // Track edge changes for save button
  const [edgeChangeFlag, setEdgeChangeFlag] = useState(false);
  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);
  
  // Track deleted items for draft mode
  const [deletedApiCalls, setDeletedApiCalls] = useState<number[]>([]);
  const [deletedModelCalls, setDeletedModelCalls] = useState<number[]>([]);
  const [deletedConditionNodes, setDeletedConditionNodes] = useState<number[]>([]);
  const [deletedStrategyTriggerNodes, setDeletedStrategyTriggerNodes] = useState<number[]>([]);
  const [deletedTelegramMessageNodes, setDeletedTelegramMessageNodes] = useState<number[]>([]);
  
  // Track user-created edges to preserve them during flow updates
  const [userCreatedEdges, setUserCreatedEdges] = useState<Edge[]>([]);

  // React Flow states
  const [nodes, setNodes, onNodesChange] = useNodesState([]);
  const [edges, setEdges, onEdgesChange] = useEdgesState([]);
  
  const api = useApi();

  const onConnect = useCallback(
    (params: Connection) => setEdges((eds) => addEdge(params, eds)),
    [setEdges]
  );

  // Track edge changes
  const onConnectWithTracking = useCallback(
    (params: Connection) => {
      const newEdge = {
        ...params,
        type: 'default',
        animated: true,
        style: { strokeWidth: 3 }
      };
      setEdges((eds) => addEdge(newEdge, eds));
      setEdgeChangeFlag(true); // Mark that edges have changed
    },
    [setEdges]
  );

  // Track edge changes (deletions)
  const onEdgesChangeWrapper = useCallback((changes: any[]) => {
    onEdgesChange(changes);
    
    // Check if any edges were removed
    const hasRemovals = changes.some(change => change.type === 'remove');
    if (hasRemovals) {
      setEdgeChangeFlag(true); // Mark that edges have changed
    }
  }, [onEdgesChange]);

  // Calculate available variables from the flow
  const getAvailableVariables = useCallback(() => {
    const variables: string[] = [];
    
    // Add variables from API calls
    apiCalls.forEach(apiCall => {
      if (apiCall.outputVariable) {
        variables.push(apiCall.outputVariable);
      }
    });
    
    // Add variables from model calls
    modelCalls.forEach(modelCall => {
      if (modelCall.outputVariable) {
        variables.push(modelCall.outputVariable);
      }
    });
    
    // Add variables from condition nodes
    conditionNodes.forEach(conditionNode => {
      if (conditionNode.trueOutputVariable) {
        variables.push(conditionNode.trueOutputVariable);
      }
      if (conditionNode.falseOutputVariable) {
        variables.push(conditionNode.falseOutputVariable);
      }
    });
    
    // Add variables from strategy trigger nodes
    strategyTriggerNodes.forEach(triggerNode => {
      if (triggerNode.outputVariable) {
        variables.push(triggerNode.outputVariable);
      }
    });
    
    return [...new Set(variables)]; // Remove duplicates
  }, [apiCalls, modelCalls, conditionNodes, strategyTriggerNodes]);

  // Update available variables when data changes
  useEffect(() => {
    setAvailableVariables(getAvailableVariables());
  }, [getAvailableVariables]);

  // Track changes for save button
  useEffect(() => {
    console.log('🔍 Checking for changes - edgeChangeFlag:', edgeChangeFlag);
    
    // Check if there are any deleted items
    const hasDeletedItems = deletedApiCalls.length > 0 || 
                           deletedModelCalls.length > 0 || 
                           deletedConditionNodes.length > 0 || 
                           deletedStrategyTriggerNodes.length > 0 || 
                           deletedTelegramMessageNodes.length > 0;
    
    console.log('🔍 Has deleted items:', hasDeletedItems, {
      apiCalls: deletedApiCalls.length,
      modelCalls: deletedModelCalls.length,
      conditionNodes: deletedConditionNodes.length,
      strategyTriggerNodes: deletedStrategyTriggerNodes.length,
      telegramMessageNodes: deletedTelegramMessageNodes.length
    });
    
    const hasChanges = edgeChangeFlag || hasDeletedItems;
    setHasUnsavedChanges(hasChanges);
  }, [edgeChangeFlag, deletedApiCalls, deletedModelCalls, deletedConditionNodes, deletedStrategyTriggerNodes, deletedTelegramMessageNodes]);

  // Load available strategies
  const loadAvailableStrategies = async () => {
    const result = await api.getStrategies();
    if (result.success && result.data) {
      setAvailableStrategies(result.data.filter((s: Strategy) => s.id !== strategyId));
    }
  };

  useEffect(() => {
    if (strategyId) {
      loadStrategyFlow();
      loadStrategy();
      loadAvailableStrategies();
    }
  }, [strategyId]);

  // Update React Flow nodes when API/model calls change
  useEffect(() => {
    updateFlowNodes();
  }, [apiCalls, modelCalls, conditionNodes, strategyTriggerNodes, telegramMessageNodes, strategy]);

  // Debug edges
  useEffect(() => {
    console.log('🔗 Edges state updated:', edges.length, 'edges');
    console.log('🔗 Current edges:', edges);
  }, [edges]);

  // Helper functions to get handle IDs for edges - improved to support condition nodes
  const getSourceHandle = (nodeId: string, handleType?: 'true' | 'false'): string | undefined => {
    if (nodeId === 'start') return undefined;
    if (nodeId.startsWith('api_call_')) return undefined;
    if (nodeId.startsWith('model_call_')) return undefined;
    if (nodeId.startsWith('condition_node_')) {
      // For condition nodes, use the specific handle type that matches the actual handle IDs
      if (handleType === 'true') return 'true';
      if (handleType === 'false') return 'false';
      return 'true'; // Default to true handle for auto-generated edges
    }
    if (nodeId.startsWith('strategy_trigger_node_')) return undefined;
    if (nodeId.startsWith('telegram_message_node_')) return undefined;
    return undefined;
  };

  const getTargetHandle = (nodeId: string): string => {
    if (nodeId === 'start-node') return 'start-input';
    if (nodeId === 'end') return 'end-input';
    if (nodeId.startsWith('api-')) return 'api-input';
    if (nodeId.startsWith('model-')) return 'model-input';
    if (nodeId.startsWith('condition-')) return 'condition-input';
    if (nodeId.startsWith('trigger-')) return 'trigger-input';
    if (nodeId.startsWith('telegram-')) return 'telegram-input';
    return 'default-input';
  };

  const updateFlowNodes = () => {
    const newNodes: Node[] = [];
    const newEdges: Edge[] = [];

    // Constants for layout
    const NODE_WIDTH = 200;
    const NODE_HEIGHT = 80;
    const HORIZONTAL_SPACING = 280; // Space between columns
    const VERTICAL_SPACING = 120; // Space between parallel nodes
    const START_X = 0;
    const CENTER_Y = 250;

    // Start node
    const startNode: Node = {
      id: 'start',
      type: 'start',
      position: { x: START_X, y: CENTER_Y - NODE_HEIGHT / 2 },
      data: {
        name: strategy?.name || 'Strategy',
        description: strategy?.description,
        cron: strategy?.cron,
        onEdit: () => setEditingStrategy(strategy)
      }
    };
    newNodes.push(startNode);

    // Combine all steps for ordering
    const allSteps = [
      ...apiCalls.map(call => ({ ...call, type: 'api_call' as const })),
      ...modelCalls.map(call => ({ ...call, type: 'model_call' as const })),
      ...conditionNodes.map(node => ({ ...node, type: 'condition_node' as const })),
      ...strategyTriggerNodes.map(node => ({ ...node, type: 'strategy_trigger_node' as const })),
      ...telegramMessageNodes.map(node => ({ ...node, type: 'telegram_message_node' as const }))
    ].sort((a, b) => a.orderIndex - b.orderIndex);

    // Group steps by order index for parallel execution
    const stepGroups: { [orderIndex: number]: any[] } = {};
    allSteps.forEach(step => {
      if (!stepGroups[step.orderIndex]) {
        stepGroups[step.orderIndex] = [];
      }
      stepGroups[step.orderIndex].push(step);
    });

    const orderedIndices = Object.keys(stepGroups).map(Number).sort((a, b) => a - b);
    let previousNodeIds: string[] = ['start'];
    let currentX = START_X + HORIZONTAL_SPACING;

    orderedIndices.forEach((orderIndex, groupIndex) => {
      const group = stepGroups[orderIndex];
      const currentNodeIds: string[] = [];
      
      // Calculate positions for this group
      group.forEach((step, stepIndex) => {
        const nodeId = `${step.type}_${step.id}`;
        currentNodeIds.push(nodeId);
        
        // Calculate Y position for proper vertical distribution
        let nodeY;
        if (group.length === 1) {
          // Single node: center it
          nodeY = CENTER_Y - NODE_HEIGHT / 2;
        } else {
          // Multiple nodes: distribute them evenly
          const totalHeight = (group.length - 1) * VERTICAL_SPACING;
          const startY = CENTER_Y - totalHeight / 2 - NODE_HEIGHT / 2;
          nodeY = startY + (stepIndex * VERTICAL_SPACING);
        }
        
        const nodeData = {
          ...step,
          onEdit: () => {
            if (step.type === 'api_call') openApiCallEditor(step);
            else if (step.type === 'model_call') setEditingModelCall(step);
            else if (step.type === 'condition_node') setEditingConditionNode(step);
            else if (step.type === 'strategy_trigger_node') setEditingStrategyTriggerNode(step);
            else if (step.type === 'telegram_message_node') setEditingTelegramMessageNode(step);
          }
        };

        let nodeType = 'apiCall';
        if (step.type === 'model_call') nodeType = 'modelCall';
        else if (step.type === 'condition_node') nodeType = 'condition';
        else if (step.type === 'strategy_trigger_node') nodeType = 'strategyTrigger';
        else if (step.type === 'telegram_message_node') nodeType = 'telegramMessage';

        const node: Node = {
          id: nodeId,
          type: nodeType,
          position: { x: currentX, y: nodeY },
          data: nodeData
        };

        newNodes.push(node);
      });

      // Only auto-generate edges if no manual edges exist
      // Check if there are existing manual connections
      const hasManualConnections = edges.some(edge => 
        edge.source.startsWith('condition_node_') && (edge.sourceHandle === 'true' || edge.sourceHandle === 'false')
      );

      if (!hasManualConnections && previousNodeIds.length > 0 && currentNodeIds.length > 0) {
        // Auto-generate basic connections
        if (previousNodeIds.length === 1 && currentNodeIds.length === 1) {
          // Simple 1-to-1 connection
          newEdges.push({
            id: `${previousNodeIds[0]}-${currentNodeIds[0]}`,
            source: previousNodeIds[0],
            target: currentNodeIds[0],
            sourceHandle: getSourceHandle(previousNodeIds[0]),
            targetHandle: getTargetHandle(currentNodeIds[0]),
            type: 'default',
            animated: true,
            style: { strokeWidth: 3 }
          });
        } else {
          // Connect each previous node to each current node
          previousNodeIds.forEach(prevId => {
            currentNodeIds.forEach(currId => {
              newEdges.push({
                id: `${prevId}-${currId}`,
                source: prevId,
                target: currId,
                sourceHandle: getSourceHandle(prevId),
                targetHandle: getTargetHandle(currId),
                type: 'default',
                animated: true,
                style: { strokeWidth: 3 }
              });
            });
          });
        }
      }

      previousNodeIds = currentNodeIds;
      currentX += HORIZONTAL_SPACING;
    });

    // Add end node if there are any steps
    if (allSteps.length > 0) {
      const endNode: Node = {
        id: 'end',
        type: 'end',
        position: { x: currentX, y: CENTER_Y - NODE_HEIGHT / 2 },
        data: {
          name: 'End',
          description: 'Flow ends here'
        }
      };
      newNodes.push(endNode);

      // Connect last group to end node (only if no manual connections)
      const hasManualConnections = edges.some(edge => 
        edge.source.startsWith('condition_node_') && (edge.sourceHandle === 'true' || edge.sourceHandle === 'false')
      );

      if (!hasManualConnections && previousNodeIds.length > 0) {
        previousNodeIds.forEach(nodeId => {
          newEdges.push({
            id: `${nodeId}-end`,
            source: nodeId,
            target: 'end',
            sourceHandle: getSourceHandle(nodeId),
            targetHandle: getTargetHandle('end'),
            type: 'default',
            animated: true,
            style: { strokeWidth: 3 }
          });
        });
      }
    }

    // If there are existing edges (manual connections), preserve them
    if (edges.length > 0) {
      // Clean up existing edges - only keep edges that reference valid nodes
      const validNodeIds = new Set(newNodes.map(node => node.id));
      const validEdges = edges.filter(edge => 
        validNodeIds.has(edge.source) && validNodeIds.has(edge.target)
      );
      setNodes(newNodes);
      setEdges(validEdges);
    } else {
      // Use auto-generated edges for initial layout
      setNodes(newNodes);
      setEdges(newEdges);
    }
  };

  const loadStrategyFlow = async () => {
    setLoading(true);
    try {
      console.log('🔗 === LOADING STRATEGY FLOW ===');
      console.log('🔗 Strategy ID:', strategyId);
      
      const [
        apiCallsResult, 
        modelCallsResult, 
        conditionNodesResult,
        strategyTriggerNodesResult,
        telegramMessageNodesResult,
        flowEdgesResult
      ] = await Promise.all([
        api.getApiCalls(strategyId),
        api.getModelCalls(strategyId),
        api.getConditionNodes(strategyId),
        api.getStrategyTriggerNodes(strategyId),
        api.getTelegramMessageNodes(strategyId),
        api.getFlowEdges(strategyId)
      ]);
      
      console.log('🔗 Raw API responses:');
      console.log('🔗 API calls result:', apiCallsResult);
      console.log('🔗 Model calls result:', modelCallsResult);
      console.log('🔗 Condition nodes result:', conditionNodesResult);
      console.log('🔗 Strategy trigger nodes result:', strategyTriggerNodesResult);
      console.log('🔗 Telegram message nodes result:', telegramMessageNodesResult);
      console.log('🔗 Flow edges result:', flowEdgesResult);
      
      if (apiCallsResult.success) {
        console.log('🔗 Setting API calls:', apiCallsResult.data);
        setApiCalls(apiCallsResult.data || []);
      } else {
        console.error('🔗 Failed to load API calls:', apiCallsResult.error);
      }
      
      if (modelCallsResult.success) {
        console.log('🔗 Setting model calls:', modelCallsResult.data);
        setModelCalls(modelCallsResult.data || []);
      } else {
        console.error('🔗 Failed to load model calls:', modelCallsResult.error);
      }

      if (conditionNodesResult.success) {
        console.log('🔗 Setting condition nodes:', conditionNodesResult.data);
        setConditionNodes(conditionNodesResult.data || []);
      } else {
        console.error('🔗 Failed to load condition nodes:', conditionNodesResult.error);
      }

      if (strategyTriggerNodesResult.success) {
        console.log('🔗 Setting strategy trigger nodes:', strategyTriggerNodesResult.data);
        setStrategyTriggerNodes(strategyTriggerNodesResult.data || []);
      } else {
        console.error('🔗 Failed to load strategy trigger nodes:', strategyTriggerNodesResult.error);
      }

      if (telegramMessageNodesResult.success) {
        console.log('🔗 Setting telegram message nodes:', telegramMessageNodesResult.data);
        setTelegramMessageNodes(telegramMessageNodesResult.data || []);
      } else {
        console.error('🔗 Failed to load telegram message nodes:', telegramMessageNodesResult.error);
      }

      if (flowEdgesResult.success) {
        console.log('🔗 Setting flow edges:', flowEdgesResult.data);
        // Convert backend edge format to React Flow edge format
        // The backend returns edges in the 'edges' field, not 'data' field
        const backendEdges = flowEdgesResult.data?.edges || [];
        
        // Ensure we have an array before mapping
        if (Array.isArray(backendEdges)) {
          const reactFlowEdges = backendEdges.map((edge: any) => ({
            id: edge.id || `${edge.source}-${edge.target}`,
            source: edge.source,
            target: edge.target,
            sourceHandle: edge.sourceHandle,
            targetHandle: edge.targetHandle,
            type: 'default',
            animated: true,
            style: { strokeWidth: 3 }
          }));
          setEdges(reactFlowEdges);
        } else {
          console.log('🔗 No edges data or not an array, setting empty edges');
          setEdges([]);
        }
      } else {
        console.error('🔗 Failed to load flow edges:', flowEdgesResult.error);
        setEdges([]);
      }
      
      console.log('🔗 === LOADING COMPLETE ===');
      setEdgeChangeFlag(false); // Reset edge changes after loading
      // Clear deleted items when loading fresh from database
      setDeletedApiCalls([]);
      setDeletedModelCalls([]);
      setDeletedConditionNodes([]);
      setDeletedStrategyTriggerNodes([]);
      setDeletedTelegramMessageNodes([]);
    } catch (error) {
      console.error('🔗 Exception while loading strategy flow:', error);
    }
    setLoading(false);
  };

  const loadStrategy = async () => {
    try {
      const result = await api.getStrategies();
      if (result.success && result.data) {
        const currentStrategy = result.data.find(s => s.id === strategyId);
        if (currentStrategy) {
          setStrategy(currentStrategy);
        }
      }
    } catch (error) {
      console.error('Error loading strategy:', error);
    }
  };

  // Helper function to open API call editor and clear test results
  const openApiCallEditor = (apiCall: ApiCall) => {
    setTestResult(null); // Clear previous test results
    setTesting(false);   // Reset testing state
    setEditingApiCall(apiCall);
  };

  const handleSaveApiCall = async (apiCall: ApiCall) => {
    try {
      console.log('🔧 Attempting to save API call:', apiCall);
      
      let result;
      if (apiCall.id) {
        console.log('🔧 Updating existing API call with ID:', apiCall.id);
        result = await api.updateApiCall(strategyId, apiCall.id, apiCall);
      } else {
        console.log('🔧 Creating new API call for strategy:', strategyId);
        result = await api.createApiCall(strategyId, apiCall);
      }
      
      console.log('🔧 API call save result:', result);
      
      if (result.success) {
        console.log('✅ API call saved successfully');
        await loadStrategyFlow();
        setEditingApiCall(null);
        setTestResult(null); // Clear test results when closing
        setTesting(false);   // Reset testing state
      } else {
        console.error('❌ Failed to save API call:', result.error);
        alert(`Failed to save API call: ${result.error}`);
      }
    } catch (error) {
      console.error('❌ Exception while saving API call:', error);
      alert(`Error saving API call: ${error}`);
    }
  };

  const handleSaveModelCall = async (modelCall: ModelCall) => {
    try {
      console.log('🔧 Attempting to save model call:', modelCall);
      
      let result;
      if (modelCall.id) {
        console.log('🔧 Updating existing model call with ID:', modelCall.id);
        result = await api.updateModelCall(strategyId, modelCall.id, modelCall);
      } else {
        console.log('🔧 Creating new model call for strategy:', strategyId);
        result = await api.createModelCall(strategyId, modelCall);
      }
      
      console.log('🔧 Model call save result:', result);
      
      if (result.success) {
        console.log('✅ Model call saved successfully');
        await loadStrategyFlow();
        setEditingModelCall(null);
      } else {
        console.error('❌ Failed to save model call:', result.error);
        alert(`Failed to save model call: ${result.error}`);
      }
    } catch (error) {
      console.error('❌ Exception while saving model call:', error);
      alert(`Error saving model call: ${error}`);
    }
  };

  const handleDeleteApiCall = async (id: number) => {
    // Mark for deletion locally instead of calling API immediately
    setDeletedApiCalls(prev => [...prev, id]);
    // Remove from current local state
    setApiCalls(prev => prev.filter(call => call.id !== id));
  };

  const handleDeleteModelCall = async (id: number) => {
    // Mark for deletion locally instead of calling API immediately
    setDeletedModelCalls(prev => [...prev, id]);
    // Remove from current local state
    setModelCalls(prev => prev.filter(call => call.id !== id));
  };

  const handleTestApiCall = async (apiCall: ApiCall) => {
    setTesting(true);
    setTestResult(null);
    
    try {
      console.log('🧪 Testing API call:', apiCall);
      const result = await api.testApiCall(apiCall);
      console.log('🧪 Test result:', result);
      setTestResult(result);
      
      // Auto-scroll to test result
      setTimeout(() => {
        const testResultElement = document.querySelector('[data-test-result]');
        if (testResultElement) {
          testResultElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
      }, 100);
    } catch (error) {
      console.error('🧪 Test error:', error);
      setTestResult({ 
        success: false, 
        error: error instanceof Error ? error.message : 'Test failed - please check console for details' 
      });
    }
    
    setTesting(false);
  };

  const handleExecuteStrategy = async () => {
    setExecuting(true);
    setExecutionLogs([]);
    
    try {
      const result = await api.runStrategy(strategyId);
      console.log('Strategy execution result:', result);
      // For now, just log the result - we'll improve logging later
    } catch (error) {
      console.error('Strategy execution failed:', error);
    }
    
    setExecuting(false);
  };

  const getNextOrderIndex = () => {
    const allSteps = [...apiCalls, ...modelCalls, ...conditionNodes, ...strategyTriggerNodes, ...telegramMessageNodes];
    return allSteps.length > 0 ? Math.max(...allSteps.map(s => s.orderIndex)) + 1 : 1;
  };

  // Calculate order index based on flow structure
  const calculateOrderFromFlow = useCallback(() => {
    const orderMap = new Map();
    
    // If no edges exist, maintain current order
    if (edges.length === 0) {
      // Just assign current order indexes
      apiCalls.forEach(call => {
        const nodeId = `api_call_${call.id}`;
        orderMap.set(nodeId, call.orderIndex);
      });
      modelCalls.forEach(call => {
        const nodeId = `model_call_${call.id}`;
        orderMap.set(nodeId, call.orderIndex);
      });
      conditionNodes.forEach(node => {
        const nodeId = `condition_node_${node.id}`;
        orderMap.set(nodeId, node.orderIndex);
      });
      strategyTriggerNodes.forEach(node => {
        const nodeId = `strategy_trigger_node_${node.id}`;
        orderMap.set(nodeId, node.orderIndex);
      });
      telegramMessageNodes.forEach(node => {
        const nodeId = `telegram_message_node_${node.id}`;
        orderMap.set(nodeId, node.orderIndex);
      });
      return orderMap;
    }
    
    // Build adjacency list from edges
    const graph = new Map();
    const incomingEdges = new Map();
    
    // Initialize all nodes
    nodes.forEach(node => {
      if (node.id !== 'start') {
        graph.set(node.id, []);
        incomingEdges.set(node.id, 0);
      }
    });
    
    // Build the graph from edges
    edges.forEach(edge => {
      const source = edge.source;
      const target = edge.target;
      
      // Skip start node for order calculation
      if (source === 'start') {
        return;
      }
      
      if (!graph.has(source)) graph.set(source, []);
      if (!graph.has(target)) graph.set(target, []);
      
      graph.get(source)!.push(target);
      incomingEdges.set(target, (incomingEdges.get(target) || 0) + 1);
    });
    
    // Find nodes that connect from start
    const startConnections: string[] = [];
    edges.forEach(edge => {
      if (edge.source === 'start') {
        startConnections.push(edge.target);
        incomingEdges.set(edge.target, 0); // Reset incoming count for start connections
      }
    });
    
    // If no start connections, use all nodes with no incoming edges
    if (startConnections.length === 0) {
      nodes.forEach(node => {
        if (node.id !== 'start' && incomingEdges.get(node.id) === 0) {
          startConnections.push(node.id);
        }
      });
    }
    
    // Topological sort to assign order indexes
    const queue = [...startConnections];
    let currentOrder = 1;
    const visited = new Set();
    
    // Process nodes level by level
    while (queue.length > 0) {
      const levelSize = queue.length;
      const currentLevel: string[] = [];
      
      // Process all nodes at the current level
      for (let i = 0; i < levelSize; i++) {
        const nodeId = queue.shift()!;
        if (visited.has(nodeId)) continue;
        
        visited.add(nodeId);
        currentLevel.push(nodeId);
        orderMap.set(nodeId, currentOrder);
        
        // Add next level nodes
        const neighbors = graph.get(nodeId) || [];
        neighbors.forEach((neighbor: string) => {
          if (!visited.has(neighbor)) {
            const newIncomingCount = incomingEdges.get(neighbor)! - 1;
            incomingEdges.set(neighbor, newIncomingCount);
            
            if (newIncomingCount === 0) {
              queue.push(neighbor);
            }
          }
        });
      }
      
      // Move to next order level if we processed any nodes
      if (currentLevel.length > 0) {
        currentOrder++;
      }
    }
    
    // Handle any remaining unconnected nodes
    nodes.forEach(node => {
      if (node.id !== 'start' && !orderMap.has(node.id)) {
        orderMap.set(node.id, currentOrder);
      }
    });
    
    console.log('🔗 Calculated order map:', Object.fromEntries(orderMap));
    return orderMap;
  }, [nodes, edges, apiCalls, modelCalls, conditionNodes, strategyTriggerNodes, telegramMessageNodes]);

  // Save flow changes
  const saveFlowChanges = async () => {
    console.log('💾 Saving flow changes...');
    try {
      const orderMap = calculateOrderFromFlow();
      const savePromises: Promise<any>[] = [];
      
      // Process deletions first
      console.log('🗑️ Processing deletions...');
      
      // Delete API calls
      for (const id of deletedApiCalls) {
        console.log('🗑️ Deleting API call:', id);
        savePromises.push(api.deleteApiCall(strategyId, id));
      }
      
      // Delete model calls
      for (const id of deletedModelCalls) {
        console.log('🗑️ Deleting model call:', id);
        savePromises.push(api.deleteModelCall(strategyId, id));
      }
      
      // Delete condition nodes
      for (const id of deletedConditionNodes) {
        console.log('🗑️ Deleting condition node:', id);
        savePromises.push(api.deleteConditionNode(strategyId, id));
      }
      
      // Delete strategy trigger nodes
      for (const id of deletedStrategyTriggerNodes) {
        console.log('🗑️ Deleting strategy trigger node:', id);
        savePromises.push(api.deleteStrategyTriggerNode(strategyId, id));
      }
      
      // Delete telegram message nodes
      for (const id of deletedTelegramMessageNodes) {
        console.log('🗑️ Deleting telegram message node:', id);
        savePromises.push(api.deleteTelegramMessageNode(strategyId, id));
      }
      
      // Update API calls with new order
      apiCalls.forEach(apiCall => {
        if (apiCall.id) {
          const nodeId = `api_call_${apiCall.id}`;
          const newOrder = orderMap.get(nodeId) || apiCall.orderIndex;
          if (newOrder !== apiCall.orderIndex) {
            const updatedApiCall = { ...apiCall, orderIndex: newOrder };
            savePromises.push(api.updateApiCall(strategyId, apiCall.id, updatedApiCall));
          }
        }
      });
      
      // Update model calls with new order
      modelCalls.forEach(modelCall => {
        if (modelCall.id) {
          const nodeId = `model_call_${modelCall.id}`;
          const newOrder = orderMap.get(nodeId) || modelCall.orderIndex;
          if (newOrder !== modelCall.orderIndex) {
            const updatedModelCall = { ...modelCall, orderIndex: newOrder };
            savePromises.push(api.updateModelCall(strategyId, modelCall.id, updatedModelCall));
          }
        }
      });
      
      // Update condition nodes with new order
      conditionNodes.forEach(conditionNode => {
        if (conditionNode.id) {
          const nodeId = `condition_node_${conditionNode.id}`;
          const newOrder = orderMap.get(nodeId) || conditionNode.orderIndex;
          if (newOrder !== conditionNode.orderIndex) {
            const updatedConditionNode = { ...conditionNode, orderIndex: newOrder };
            savePromises.push(api.updateConditionNode(strategyId, conditionNode.id, updatedConditionNode));
          }
        }
      });
      
      // Update strategy trigger nodes with new order
      strategyTriggerNodes.forEach(triggerNode => {
        if (triggerNode.id) {
          const nodeId = `strategy_trigger_node_${triggerNode.id}`;
          const newOrder = orderMap.get(nodeId) || triggerNode.orderIndex;
          if (newOrder !== triggerNode.orderIndex) {
            const updatedTriggerNode = { ...triggerNode, orderIndex: newOrder };
            savePromises.push(api.updateStrategyTriggerNode(strategyId, triggerNode.id, updatedTriggerNode));
          }
        }
      });
      
      // Update telegram message nodes with new order
      telegramMessageNodes.forEach(telegramNode => {
        if (telegramNode.id) {
          const nodeId = `telegram_message_node_${telegramNode.id}`;
          const newOrder = orderMap.get(nodeId) || telegramNode.orderIndex;
          if (newOrder !== telegramNode.orderIndex) {
            const updatedTelegramNode = { ...telegramNode, orderIndex: newOrder };
            savePromises.push(api.updateTelegramMessageNode(strategyId, telegramNode.id, updatedTelegramNode));
          }
        }
      });
      
      // Save/delete flow edges
      console.log('🔗 Processing flow edges...');
      
      // First, get current edges from database to compare
      const currentEdgesResult = await api.getFlowEdges(strategyId);
      
      // Handle the API response format where edges are in the 'edges' field
      let currentEdges: any[] = [];
      if (currentEdgesResult.success) {
        currentEdges = currentEdgesResult.data?.edges || [];
        
        // Ensure it's an array
        if (!Array.isArray(currentEdges)) {
          console.log('🔗 Current edges data is not an array, using empty array');
          currentEdges = [];
        }
      }
      
      const currentEdgeIds = new Set(currentEdges.map((edge: any) => edge.id || `${edge.source}-${edge.target}`));
      
      // Get current React Flow edges
      const reactFlowEdgeIds = new Set(edges.map(edge => edge.id));
      
      // Delete edges that are in database but not in React Flow
      for (const currentEdge of currentEdges) {
        const edgeId = currentEdge.id || `${currentEdge.source}-${currentEdge.target}`;
        if (!reactFlowEdgeIds.has(edgeId)) {
          console.log('🗑️ Deleting edge:', edgeId);
          savePromises.push(api.deleteFlowEdge(strategyId, edgeId));
        }
      }
      
      // Create edges that are in React Flow but not in database
      for (const reactFlowEdge of edges) {
        if (!currentEdgeIds.has(reactFlowEdge.id)) {
          console.log('➕ Creating edge:', reactFlowEdge.id);
          savePromises.push(api.createFlowEdge(strategyId, {
            sourceNodeId: reactFlowEdge.source,
            targetNodeId: reactFlowEdge.target,
            sourceHandle: reactFlowEdge.sourceHandle || undefined,
            targetHandle: reactFlowEdge.targetHandle || undefined
          }));
        }
      }

      if (savePromises.length > 0) {
        const totalDeletions = deletedApiCalls.length + deletedModelCalls.length + deletedConditionNodes.length + deletedStrategyTriggerNodes.length + deletedTelegramMessageNodes.length;
        console.log(`💾 Processing ${savePromises.length} operations (${totalDeletions} deletions, ${savePromises.length - totalDeletions} updates)...`);
        const results = await Promise.all(savePromises);
        const failures = results.filter(result => !result.success);
        
        if (failures.length > 0) {
          console.error('❌ Some operations failed:', failures);
          alert(`Failed to process ${failures.length} operations. Check console for details.`);
        } else {
          console.log('✅ All flow changes saved successfully');
          // Clear deleted items state
          setDeletedApiCalls([]);
          setDeletedModelCalls([]);
          setDeletedConditionNodes([]);
          setDeletedStrategyTriggerNodes([]);
          setDeletedTelegramMessageNodes([]);
          // Reload data to reflect the new order
          await loadStrategyFlow();
        }
      } else {
        console.log('✅ No changes to save');
      }
      
      setEdgeChangeFlag(false);
      setHasUnsavedChanges(false);
    } catch (error) {
      console.error('❌ Error saving flow changes:', error);
      alert(`Error saving flow: ${error}`);
    }
  };

  const renderFlowView = () => {
    return (
      <div className="space-y-4">
        <div className="flex justify-between items-center">
          <div className="flex flex-wrap gap-2">
            <Button 
              onClick={() => openApiCallEditor({
                name: '',
                url: '',
                method: 'GET',
                outputVariable: '',
                orderIndex: getNextOrderIndex(),
                enabled: true
              })} 
              className="flex items-center space-x-2 bg-gray-600 hover:bg-gray-700"
            >
              <GlobeIcon className="w-4 h-4" />
              <span>API Call</span>
            </Button>
            <Button 
              onClick={() => setEditingModelCall({
                name: '',
                modelTier: 'cheap',
                userPrompt: '',
                includeApiData: true,
                outputVariable: '',
                orderIndex: getNextOrderIndex(),
                enabled: true
              })} 
              className="flex items-center space-x-2 bg-gray-600 hover:bg-gray-700"
            >
              <BrainIcon className="w-4 h-4" />
              <span>Model Call</span>
            </Button>
            <Button 
              onClick={() => setEditingConditionNode({
                name: '',
                conditionType: 'api_result',
                leftOperand: '',
                operator: '==',
                rightOperand: '',
                orderIndex: getNextOrderIndex(),
                enabled: true
              })} 
              className="flex items-center space-x-2 bg-gray-600 hover:bg-gray-700"
            >
              <InformationCircleIcon className="w-4 h-4" />
              <span>Condition</span>
            </Button>
            <Button 
              onClick={() => setEditingStrategyTriggerNode({
                name: '',
                targetStrategyId: 0,
                waitForCompletion: false,
                orderIndex: getNextOrderIndex(),
                enabled: true
              })} 
              className="flex items-center space-x-2 bg-gray-600 hover:bg-gray-700"
            >
              <ArrowPathIcon className="w-4 h-4" />
              <span>Trigger Strategy</span>
            </Button>
            <Button 
              onClick={() => setEditingTelegramMessageNode({
                name: '',
                chatId: '',
                messageTemplate: '',
                includeApiData: false,
                messageType: 'info',
                parseMode: 'Markdown',
                orderIndex: getNextOrderIndex(),
                enabled: true
              })} 
              className="flex items-center space-x-2 bg-gray-600 hover:bg-gray-700"
            >
              <ChatBubbleLeftIcon className="w-4 h-4" />
              <span>Send to Telegram</span>
            </Button>
            <Button 
              onClick={() => {
                const endNode: Node = {
                  id: 'end',
                  type: 'end',
                  position: { x: 800, y: 200 },
                  data: {
                    name: 'End',
                    description: 'Flow ends here'
                  }
                };
                setNodes(prev => [...prev, endNode]);
              }} 
              className="flex items-center space-x-2 bg-gray-600 hover:bg-gray-700"
            >
              <XMarkIcon className="w-4 h-4" />
              <span>End Node</span>
            </Button>
          </div>
          <Button 
            onClick={handleExecuteStrategy} 
            disabled={executing} 
            className="flex items-center space-x-2 bg-green-600 hover:bg-green-700"
          >
            <PlayIcon className="w-4 h-4" />
            <span>{executing ? 'Executing...' : 'Run Strategy'}</span>
          </Button>
        </div>

        {hasUnsavedChanges && (
          <div className="bg-orange-900/20 border border-orange-700 rounded-lg p-3">
            <div className="flex items-center justify-between">
              <div className="flex items-center space-x-2">
                <div className="w-2 h-2 bg-orange-400 rounded-full animate-pulse"></div>
                <span className="text-orange-300 text-sm">You have unsaved changes (edges or deletions)</span>
              </div>
              <div className="flex space-x-2">
                <Button 
                  onClick={() => {
                    setEdgeChangeFlag(false);
                    setHasUnsavedChanges(false);
                    loadStrategyFlow(); // Reload to reset edges
                  }}
                  className="bg-gray-600 hover:bg-gray-700 text-white"
                  size="sm"
                >
                  Reset Layout
                </Button>
                <Button 
                  onClick={saveFlowChanges}
                  className="bg-orange-600 hover:bg-orange-700 text-white"
                  size="sm"
                >
                  Save Changes
                </Button>
              </div>
            </div>
          </div>
        )}

        <div className="h-[500px] bg-gray-900 rounded-lg border border-gray-700 relative overflow-hidden">
          <ReactFlow
            nodes={nodes}
            edges={edges}
            onNodesChange={onNodesChange}
            onEdgesChange={onEdgesChangeWrapper}
            onConnect={onConnectWithTracking}
            nodeTypes={nodeTypes}
            defaultEdgeOptions={edgeOptions}
            fitView
            fitViewOptions={{ 
              padding: 0.05, 
              minZoom: 0.4, 
              maxZoom: 1.5,
              includeHiddenNodes: false
            }}
            defaultViewport={{ x: 0, y: 0, zoom: 0.8 }}
            className="bg-gray-900"
            connectionLineStyle={{ stroke: '#ffffff', strokeWidth: 2 }}
            connectionLineType={ConnectionLineType.Bezier}
            proOptions={{ hideAttribution: true }}
            elementsSelectable={true}
            nodesConnectable={true}
            nodesDraggable={true}
            zoomOnScroll={true}
            panOnScroll={false}
            selectNodesOnDrag={false}
            snapToGrid={true}
            snapGrid={[20, 20]}
            onInit={(reactFlowInstance) => {
              // Fit view with slight delay to ensure all nodes are rendered
              setTimeout(() => {
                reactFlowInstance.fitView({ 
                  padding: 0.08, 
                  minZoom: 0.4, 
                  maxZoom: 1.3,
                  duration: 600 
                });
              }, 200);
            }}
          >
            <Controls className="bg-gray-800 border border-gray-600 text-white" />
            <Background color="#374151" gap={16} variant={BackgroundVariant.Dots} />
          </ReactFlow>
        </div>

        {nodes.length === 0 && (
          <Card>
            <CardContent className="p-8 text-center">
              <h3 className="text-xl font-semibold text-white mb-2">No Flow Steps Configured</h3>
              <p className="text-gray-400 mb-4">
                Add API calls and model calls to build your strategy flow
              </p>
              <div className="flex justify-center space-x-4">
                <Button onClick={() => openApiCallEditor({
                  name: '',
                  url: '',
                  method: 'GET',
                  outputVariable: '',
                  orderIndex: getNextOrderIndex(),
                  enabled: true
                })}>
                  <GlobeIcon className="w-4 h-4 mr-2" />
                  Add API Call
                </Button>
                <Button onClick={() => setEditingModelCall({
                  name: '',
                  modelTier: 'cheap',
                  userPrompt: '',
                  includeApiData: true,
                  outputVariable: '',
                  orderIndex: getNextOrderIndex(),
                  enabled: true
                })}>
                  <BrainIcon className="w-4 h-4 mr-2" />
                  Add Model Call
                </Button>
              </div>
            </CardContent>
          </Card>
        )}

        {executionLogs.length > 0 && (
          <Card>
            <CardHeader>
              <CardTitle className="text-white">Execution Logs</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="space-y-2">
                {executionLogs.map((log, index) => (
                  <div key={index} className="flex items-start space-x-3 p-3 bg-gray-800 rounded">
                    <div className="flex-shrink-0">
                      {log.error ? (
                        <XMarkIcon className="w-4 h-4 text-red-400" />
                      ) : (
                        <CheckIcon className="w-4 h-4 text-green-400" />
                      )}
                    </div>
                    <div className="flex-1">
                      <p className="text-sm font-medium text-white">{log.stepName}</p>
                      <p className="text-xs text-gray-400">{log.duration}ms</p>
                      {log.error && (
                        <p className="text-xs text-red-400 mt-1">{log.error}</p>
                      )}
                    </div>
                  </div>
                ))}
              </div>
            </CardContent>
          </Card>
        )}
      </div>
    );
  };

  const renderApiCallsTab = () => (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <h3 className="text-lg font-semibold text-white">API Calls</h3>
        <Button onClick={() => openApiCallEditor({
          name: '',
          url: '',
          method: 'GET',
          outputVariable: '',
          orderIndex: getNextOrderIndex(),
          enabled: true
        })} className="flex items-center space-x-2">
          <PlusIcon className="w-4 h-4" />
          <span>Add API Call</span>
        </Button>
      </div>

      <div className="grid gap-4">
        {apiCalls.map((apiCall) => (
          <Card key={apiCall.id}>
            <CardContent className="p-4">
              <div className="flex justify-between items-start">
                <div>
                  <h4 className="font-medium text-white">{apiCall.name}</h4>
                  <p className="text-sm text-gray-400">{apiCall.method} {apiCall.url}</p>
                  <p className="text-xs text-green-400">Output: {apiCall.outputVariable}</p>
                  {apiCall.jsonPath && (
                    <p className="text-xs text-blue-400">JSON Path: {apiCall.jsonPath}</p>
                  )}
                  {!apiCall.jsonPath && (
                    <p className="text-xs text-yellow-400">Full response will be stored</p>
                  )}
                </div>
                <div className="flex items-center space-x-2">
                  <Button 
                    size="sm" 
                    variant="outline" 
                    onClick={() => handleTestApiCall(apiCall)}
                    disabled={testing}
                    className={testing ? 'opacity-50 cursor-not-allowed' : ''}
                  >
                    {testing ? (
                      <div className="w-4 h-4 animate-spin rounded-full border-2 border-gray-300 border-t-blue-600"></div>
                    ) : (
                      <TestTubeIcon className="w-4 h-4" />
                    )}
                    {testing ? 'Testing...' : 'Test'}
                  </Button>
                  <Button size="sm" variant="outline" onClick={() => openApiCallEditor(apiCall)}>
                    <EditIcon className="w-4 h-4" />
                  </Button>
                  <Button size="sm" variant="error" onClick={() => handleDeleteApiCall(apiCall.id!)}>
                    <TrashIcon className="w-4 h-4" />
                  </Button>
                </div>
              </div>
            </CardContent>
          </Card>
        ))}
      </div>

      {testResult && (
        <Card data-test-result>
          <CardHeader>
            <CardTitle className="text-white flex items-center space-x-2">
              {testResult.success ? (
                <CheckIcon className="w-5 h-5 text-green-400" />
              ) : (
                <XMarkIcon className="w-5 h-5 text-red-400" />
              )}
              <span>Test Result {testResult.success ? '✅' : '❌'}</span>
            </CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            {testResult.success ? (
              <>
                {testResult.data?.extractedValue !== undefined && (
                  <div>
                    <h4 className="text-sm font-medium text-green-400 mb-2">
                      ✨ Extracted Value (JSON Path: {testResult.jsonPath || 'N/A'})
                    </h4>
                    <div className="bg-green-900/20 border border-green-700 rounded p-3">
                      <code className="text-green-300 text-sm">
                        {Array.isArray(testResult.data.extractedValue) 
                          ? JSON.stringify(testResult.data.extractedValue[0], null, 2)
                          : JSON.stringify(testResult.data.extractedValue, null, 2)
                        }
                      </code>
                    </div>
                    <p className="text-xs text-green-400 mt-2">
                      This value will be stored in the "{testResult.outputVariable || 'output'}" variable
                    </p>
                  </div>
                )}
                
                <div>
                  <h4 className="text-sm font-medium text-blue-400 mb-2">📄 Full API Response</h4>
                  <pre className="text-xs bg-gray-800 p-3 rounded text-gray-300 overflow-auto max-h-40 border border-gray-600">
                    {JSON.stringify(testResult.data?.data || testResult.data, null, 2)}
                  </pre>
                </div>
                
                <div className="bg-green-900/10 border border-green-700 rounded p-3">
                  <p className="text-sm text-green-300">
                    🎉 API call successful! The extracted value will be available as a variable in your flow.
                  </p>
                </div>
              </>
            ) : (
              <div>
                <h4 className="text-sm font-medium text-red-400 mb-2">❌ Error Details</h4>
                <div className="bg-red-900/20 border border-red-700 rounded p-3">
                  <code className="text-red-300 text-sm">
                    {testResult.error || 'Unknown error occurred'}
                  </code>
                </div>
                <div className="bg-yellow-900/10 border border-yellow-700 rounded p-3 mt-3">
                  <p className="text-sm text-yellow-300">
                    💡 Troubleshooting tips:
                  </p>
                  <ul className="text-xs text-yellow-200 mt-2 space-y-1 list-disc list-inside">
                    <li>Check if the URL is accessible and returns valid JSON</li>
                    <li>Verify that any required headers are properly formatted</li>
                    <li>Test the JSON Path syntax if you're extracting specific values</li>
                    <li>Check the browser's network tab for more details</li>
                  </ul>
                </div>
              </div>
            )}
          </CardContent>
        </Card>
      )}
    </div>
  );

  const renderModelCallsTab = () => (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <h3 className="text-lg font-semibold text-white">Model Calls</h3>
        <Button onClick={() => setEditingModelCall({
          name: '',
          modelTier: 'cheap',
          userPrompt: '',
          includeApiData: true,
          outputVariable: '',
          orderIndex: getNextOrderIndex(),
          enabled: true
        })} className="flex items-center space-x-2">
          <PlusIcon className="w-4 h-4" />
          <span>Add Model Call</span>
        </Button>
      </div>

      <div className="grid gap-4">
        {modelCalls.map((modelCall) => (
          <Card key={modelCall.id}>
            <CardContent className="p-4">
              <div className="flex justify-between items-start">
                <div>
                  <h4 className="font-medium text-white">{modelCall.name}</h4>
                  <p className="text-sm text-gray-400">{modelCall.modelTier} model</p>
                  <p className="text-xs text-green-400">Output: {modelCall.outputVariable}</p>
                  <p className="text-xs text-purple-400">
                    {modelCall.includeApiData ? 'Includes API data' : 'No API data'}
                  </p>
                </div>
                <div className="flex items-center space-x-2">
                  <Button size="sm" variant="outline" onClick={() => setEditingModelCall(modelCall)}>
                    <EditIcon className="w-4 h-4" />
                  </Button>
                  <Button size="sm" variant="error" onClick={() => handleDeleteModelCall(modelCall.id!)}>
                    <TrashIcon className="w-4 h-4" />
                  </Button>
                </div>
              </div>
            </CardContent>
          </Card>
        ))}
      </div>
    </div>
  );

  const renderConditionNodesTab = () => (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <h3 className="text-lg font-semibold text-white">Condition Nodes</h3>
        <Button onClick={() => setEditingConditionNode({
          name: '',
          conditionType: 'api_result',
          leftOperand: '',
          operator: '==',
          rightOperand: '',
          orderIndex: getNextOrderIndex(),
          enabled: true
        })} className="flex items-center space-x-2">
          <PlusIcon className="w-4 h-4" />
          <span>Add Condition</span>
        </Button>
      </div>

      <div className="grid gap-4">
        {conditionNodes.map((conditionNode) => (
          <Card key={conditionNode.id}>
            <CardContent className="p-4">
              <div className="flex justify-between items-start">
                <div>
                  <h4 className="font-medium text-white">{conditionNode.name}</h4>
                  <p className="text-sm text-gray-400">{conditionNode.conditionType}</p>
                  <p className="text-xs text-yellow-400">
                    {conditionNode.leftOperand} {conditionNode.operator} {conditionNode.rightOperand}
                  </p>
                  <p className="text-xs text-green-400">
                    True → {conditionNode.trueOutputVariable || 'true'} | False → {conditionNode.falseOutputVariable || 'false'}
                  </p>
                </div>
                <div className="flex items-center space-x-2">
                  <Button size="sm" variant="outline" onClick={() => setEditingConditionNode(conditionNode)}>
                    <EditIcon className="w-4 h-4" />
                  </Button>
                  <Button size="sm" variant="error" onClick={() => handleDeleteConditionNode(conditionNode.id!)}>
                    <TrashIcon className="w-4 h-4" />
                  </Button>
                </div>
              </div>
            </CardContent>
          </Card>
        ))}
      </div>
    </div>
  );

  const renderStrategyTriggerNodesTab = () => (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <h3 className="text-lg font-semibold text-white">Strategy Trigger Nodes</h3>
        <Button onClick={() => setEditingStrategyTriggerNode({
          name: '',
          targetStrategyId: 0,
          waitForCompletion: false,
          orderIndex: getNextOrderIndex(),
          enabled: true
        })} className="flex items-center space-x-2">
          <PlusIcon className="w-4 h-4" />
          <span>Add Trigger</span>
        </Button>
      </div>

      <div className="grid gap-4">
        {strategyTriggerNodes.map((triggerNode) => (
          <Card key={triggerNode.id}>
            <CardContent className="p-4">
              <div className="flex justify-between items-start">
                <div>
                  <h4 className="font-medium text-white">{triggerNode.name}</h4>
                  <p className="text-sm text-gray-400">→ Strategy #{triggerNode.targetStrategyId}</p>
                  <p className="text-xs text-orange-400">
                    {triggerNode.waitForCompletion ? 'Wait for completion' : 'Fire & forget'}
                  </p>
                  {triggerNode.conditionVariable && (
                    <p className="text-xs text-orange-400">If: {triggerNode.conditionVariable}</p>
                  )}
                </div>
                <div className="flex items-center space-x-2">
                  <Button size="sm" variant="outline" onClick={() => setEditingStrategyTriggerNode(triggerNode)}>
                    <EditIcon className="w-4 h-4" />
                  </Button>
                  <Button size="sm" variant="error" onClick={() => {
                    // We need to add a delete handler here
                    if (window.confirm('Are you sure you want to delete this strategy trigger?')) {
                      // The delete handler will be passed down
                      if (triggerNode.id) {
                        handleDeleteStrategyTriggerNode(triggerNode.id!);
                      }
                    }
                  }}>
                    <TrashIcon className="w-4 h-4" />
                  </Button>
                </div>
              </div>
            </CardContent>
          </Card>
        ))}
      </div>
    </div>
  );

  const renderTelegramMessageNodesTab = () => (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <h3 className="text-lg font-semibold text-white">Telegram Message Nodes</h3>
        <Button onClick={() => setEditingTelegramMessageNode({
          name: '',
          chatId: '',
          messageTemplate: '',
          includeApiData: false,
          messageType: 'info',
          parseMode: 'Markdown',
          orderIndex: getNextOrderIndex(),
          enabled: true
        })} className="flex items-center space-x-2">
          <PlusIcon className="w-4 h-4" />
          <span>Add Telegram Message</span>
        </Button>
      </div>

      <div className="grid gap-4">
        {telegramMessageNodes.map((telegramNode) => (
          <Card key={telegramNode.id}>
            <CardContent className="p-4">
              <div className="flex justify-between items-start">
                <div>
                  <h4 className="font-medium text-white">{telegramNode.name}</h4>
                  <p className="text-sm text-gray-400">#{telegramNode.chatId}</p>
                  <p className="text-xs text-green-400">{telegramNode.messageType} message</p>
                  <p className="text-xs text-green-400">
                    {telegramNode.onlyIfVariable ? `Only if: ${telegramNode.onlyIfVariable}` : 'Always send'}
                  </p>
                </div>
                <div className="flex items-center space-x-2">
                  <Button size="sm" variant="outline" onClick={() => setEditingTelegramMessageNode(telegramNode)}>
                    <EditIcon className="w-4 h-4" />
                  </Button>
                  <Button size="sm" variant="error" onClick={() => handleDeleteTelegramMessageNode(telegramNode.id!)}>
                    <TrashIcon className="w-4 h-4" />
                  </Button>
                </div>
              </div>
            </CardContent>
          </Card>
        ))}
      </div>
    </div>
  );

  const handleSaveConditionNode = async (conditionNode: ConditionNode) => {
    try {
      let result;
      if (conditionNode.id) {
        result = await api.updateConditionNode(strategyId, conditionNode.id, conditionNode);
      } else {
        result = await api.createConditionNode(strategyId, conditionNode);
      }
      
      if (result.success) {
        await loadStrategyFlow();
        setEditingConditionNode(null);
      } else {
        alert(`Failed to save condition node: ${result.error}`);
      }
    } catch (error) {
      alert(`Error saving condition node: ${error}`);
    }
  };

  const handleDeleteConditionNode = async (id: number) => {
    // Mark for deletion locally instead of calling API immediately
    setDeletedConditionNodes(prev => [...prev, id]);
    // Remove from current local state
    setConditionNodes(prev => prev.filter(node => node.id !== id));
  };

  const handleSaveStrategyTriggerNode = async (triggerNode: StrategyTriggerNode) => {
    try {
      let result;
      if (triggerNode.id) {
        result = await api.updateStrategyTriggerNode(strategyId, triggerNode.id, triggerNode);
      } else {
        result = await api.createStrategyTriggerNode(strategyId, triggerNode);
      }
      
      if (result.success) {
        await loadStrategyFlow();
        setEditingStrategyTriggerNode(null);
      } else {
        alert(`Failed to save strategy trigger node: ${result.error}`);
      }
    } catch (error) {
      alert(`Error saving strategy trigger node: ${error}`);
    }
  };

  const handleDeleteStrategyTriggerNode = async (id: number) => {
    // Mark for deletion locally instead of calling API immediately
    setDeletedStrategyTriggerNodes(prev => [...prev, id]);
    // Remove from current local state
    setStrategyTriggerNodes(prev => prev.filter(node => node.id !== id));
  };

  const handleSaveTelegramMessageNode = async (telegramNode: TelegramMessageNode) => {
    try {
      let result;
      if (telegramNode.id) {
        result = await api.updateTelegramMessageNode(strategyId, telegramNode.id, telegramNode);
      } else {
        result = await api.createTelegramMessageNode(strategyId, telegramNode);
      }
      
      if (result.success) {
        await loadStrategyFlow();
        setEditingTelegramMessageNode(null);
      } else {
        alert(`Failed to save telegram message node: ${result.error}`);
      }
    } catch (error) {
      alert(`Error saving telegram message node: ${error}`);
    }
  };

  const handleDeleteTelegramMessageNode = async (id: number) => {
    // Mark for deletion locally instead of calling API immediately
    setDeletedTelegramMessageNodes(prev => [...prev, id]);
    // Remove from current local state
    setTelegramMessageNodes(prev => prev.filter(node => node.id !== id));
  };

  const handleSaveStrategy = async (strategyData: any) => {
    try {
      const result = await api.updateStrategy(strategyId, strategyData);
      if (result.success) {
        await loadStrategy();
        // Refresh parent component's strategy data
        if (onRefetch) {
          await onRefetch();
        }
        setEditingStrategy(null);
        // Success feedback will be visible through the updated UI
      } else {
        alert(`Failed to update strategy: ${result.error}`);
      }
    } catch (error) {
      alert(`Error updating strategy: ${error}`);
    }
  };

  // Add ESC key handler for main strategy flow editor
  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (event.key === 'Escape') {
        // Check if any node editor is open - if so, don't close the main editor
        // The individual node editors will handle their own ESC behavior
        const hasOpenEditor = editingApiCall || 
                             editingModelCall || 
                             editingConditionNode || 
                             editingStrategyTriggerNode || 
                             editingTelegramMessageNode || 
                             editingStrategy;
        
        if (!hasOpenEditor) {
          onClose();
        }
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => {
      document.removeEventListener('keydown', handleKeyDown);
    };
  }, [onClose, editingApiCall, editingModelCall, editingConditionNode, editingStrategyTriggerNode, editingTelegramMessageNode, editingStrategy]);

  if (loading) {
    return (
      <div className="fixed inset-0 z-50 bg-black/60 backdrop-blur-sm flex items-center justify-center">
        <div className="text-blue-400">Loading strategy flow...</div>
      </div>
    );
  }

  return (
    <div className="fixed inset-0 z-50 bg-black/60 backdrop-blur-sm">
      <div className="h-full overflow-y-auto">
        <div className="min-h-full flex items-center justify-center p-4">
          <Card className="w-full max-w-6xl max-h-[85vh] overflow-hidden">
            <CardHeader className="border-b pb-3">
              <div className="flex justify-between items-center">
                <div className="flex items-center space-x-3">
                  <CardTitle className="text-xl text-white">Strategy Flow Editor</CardTitle>
                  <Button 
                    variant="outline" 
                    size="sm"
                    onClick={() => setEditingStrategy(strategy)}
                    className="flex items-center space-x-1"
                  >
                    <EditIcon className="w-4 h-4" />
                  </Button>
                </div>
                <Button variant="outline" onClick={onClose}>
                  <XMarkIcon className="w-4 h-4" />
                </Button>
              </div>
            </CardHeader>
            
            <CardContent className="max-h-[65vh] overflow-y-auto p-4">
              {renderFlowView()}
            </CardContent>
          </Card>
        </div>
      </div>

      {/* API Call Editor Modal */}
      {editingApiCall && (
        <ApiCallEditor
          apiCall={editingApiCall}
          onSave={handleSaveApiCall}
          onCancel={() => {
            setEditingApiCall(null);
            setTestResult(null);
            setTesting(false);
          }}
          onDelete={editingApiCall.id ? () => {
            handleDeleteApiCall(editingApiCall.id!);
            setEditingApiCall(null);
            setTestResult(null);
            setTesting(false);
          } : undefined}
          testResult={testResult}
          testing={testing}
          onTest={handleTestApiCall}
        />
      )}

      {/* Model Call Editor Modal */}
      {editingModelCall && (
        <ModelCallEditor
          modelCall={editingModelCall}
          onSave={handleSaveModelCall}
          onCancel={() => setEditingModelCall(null)}
          onDelete={editingModelCall.id ? () => {
            handleDeleteModelCall(editingModelCall.id!);
            setEditingModelCall(null);
          } : undefined}
        />
      )}

      {/* Condition Node Editor Modal */}
      {editingConditionNode && (
        <ConditionNodeEditor
          conditionNode={editingConditionNode}
          onSave={handleSaveConditionNode}
          onCancel={() => setEditingConditionNode(null)}
          onDelete={editingConditionNode.id ? () => {
            handleDeleteConditionNode(editingConditionNode.id!);
            setEditingConditionNode(null);
          } : undefined}
          availableVariables={availableVariables}
          apiCalls={apiCalls}
          modelCalls={modelCalls}
        />
      )}

      {/* Strategy Trigger Node Editor Modal */}
      {editingStrategyTriggerNode && (
        <StrategyTriggerNodeEditor
          triggerNode={editingStrategyTriggerNode}
          onSave={handleSaveStrategyTriggerNode}
          onCancel={() => setEditingStrategyTriggerNode(null)}
          onDelete={editingStrategyTriggerNode.id ? () => {
            handleDeleteStrategyTriggerNode(editingStrategyTriggerNode.id!);
            setEditingStrategyTriggerNode(null);
          } : undefined}
          availableStrategies={availableStrategies}
          availableVariables={availableVariables}
        />
      )}

      {/* Telegram Message Node Editor Modal */}
      {editingTelegramMessageNode && (
        <TelegramMessageNodeEditor
          telegramNode={editingTelegramMessageNode}
          onSave={handleSaveTelegramMessageNode}
          onCancel={() => setEditingTelegramMessageNode(null)}
          onDelete={editingTelegramMessageNode.id ? () => {
            handleDeleteTelegramMessageNode(editingTelegramMessageNode.id!);
            setEditingTelegramMessageNode(null);
          } : undefined}
        />
      )}

      {/* Strategy Settings Editor Modal */}
      {editingStrategy && (
        <StrategySettingsEditor
          strategy={editingStrategy}
          onSave={handleSaveStrategy}
          onCancel={() => setEditingStrategy(null)}
        />
      )}
    </div>
  );
}

// Condition Node Editor Component
function ConditionNodeEditor({ 
  conditionNode, 
  onSave, 
  onCancel, 
  onDelete,
  availableVariables, 
  apiCalls, 
  modelCalls 
}: { 
  conditionNode: ConditionNode; 
  onSave: (conditionNode: ConditionNode) => void; 
  onCancel: () => void;
  onDelete?: () => void;
  availableVariables: string[];
  apiCalls: ApiCall[];
  modelCalls: ModelCall[];
}) {
  const [formData, setFormData] = useState(conditionNode);

  // Add ESC key handler for condition node editor
  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (event.key === 'Escape') {
        onCancel();
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => {
      document.removeEventListener('keydown', handleKeyDown);
    };
  }, [onCancel]);

  // Filter available variables based on condition type
  const getFilteredVariables = () => {
    switch (formData.conditionType) {
      case 'api_result':
        return apiCalls
          .filter(call => call.outputVariable)
          .map(call => call.outputVariable);
      case 'model_response':
        return modelCalls
          .filter(call => call.outputVariable)
          .map(call => call.outputVariable);
      case 'variable_value':
      default:
        return availableVariables;
    }
  };

  // Get variables that are marked as numeric (castToNumber = true for API calls)
  const getNumericVariables = () => {
    return apiCalls
      .filter(call => call.outputVariable && call.castToNumber)
      .map(call => call.outputVariable);
  };

  // Check if the current operator requires numeric operands
  const isNumericOperator = (operator: string) => {
    return ['>', '<', '>=', '<='].includes(operator);
  };

  // Get appropriate variables based on operator type
  const getOperatorFilteredVariables = () => {
    if (isNumericOperator(formData.operator)) {
      // For numeric operators, only show numeric variables
      if (formData.conditionType === 'api_result') {
        return apiCalls
          .filter(call => call.outputVariable && call.castToNumber)
          .map(call => call.outputVariable);
      } else {
        // For non-API results, we can't guarantee they're numeric
        return [];
      }
    } else {
      // For non-numeric operators, show all variables
      return getFilteredVariables();
    }
  };

  const filteredVariables = getOperatorFilteredVariables();
  const numericVariables = getNumericVariables();

  return (
    <div className="fixed inset-0 z-60 bg-black/80 backdrop-blur-sm flex items-center justify-center p-4">
      <Card className="w-full max-w-2xl">
        <CardHeader>
          <CardTitle className="text-white">
            {conditionNode.id ? 'Edit Condition Node' : 'New Condition Node'}
          </CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="grid grid-cols-2 gap-4">
            <div>
              <Label htmlFor="name">Name</Label>
              <Input
                id="name"
                value={formData.name}
                onChange={(e) => setFormData({...formData, name: e.target.value})}
                placeholder="Price Check"
              />
            </div>
            <div>
              <Label htmlFor="conditionType">Condition Type</Label>
              <select
                value={formData.conditionType}
                onChange={(e) => {
                  const newConditionType = e.target.value as any;
                  setFormData({
                    ...formData, 
                    conditionType: newConditionType,
                    leftOperand: '' // Reset left operand when type changes
                  });
                }}
                className="flex h-10 w-full rounded-md border border-gray-600 bg-gray-800 px-3 py-2 text-sm text-white focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent disabled:cursor-not-allowed disabled:opacity-50"
              >
                <option value="variable_value">Variable Value (Any)</option>
                <option value="api_result">API Result</option>
                <option value="model_response">Model Response</option>
              </select>
              <p className="text-xs text-gray-400 mt-1">
                {formData.conditionType === 'api_result' && 'Compare values from API calls'}
                {formData.conditionType === 'model_response' && 'Compare values from model responses'}
                {formData.conditionType === 'variable_value' && 'Compare any available variable'}
              </p>
            </div>
          </div>

          <div className="grid grid-cols-3 gap-4">
            <div>
              <Label htmlFor="leftOperand">
                Left Operand {formData.conditionType === 'api_result' ? '(API Variables)' : 
                            formData.conditionType === 'model_response' ? '(Model Variables)' : 
                            '(All Variables)'}
              </Label>
              <select
                value={formData.leftOperand}
                onChange={(e) => setFormData({...formData, leftOperand: e.target.value})}
                className="flex h-10 w-full rounded-md border border-gray-600 bg-gray-800 px-3 py-2 text-sm text-white focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent disabled:cursor-not-allowed disabled:opacity-50"
              >
                <option value="">
                  {formData.conditionType === 'api_result' ? 'Select API variable' :
                   formData.conditionType === 'model_response' ? 'Select model variable' :
                   'Select a variable'}
                </option>
                {filteredVariables.map(variable => {
                  // Find the source of this variable for better context
                  const apiSource = apiCalls.find(call => call.outputVariable === variable);
                  const modelSource = modelCalls.find(call => call.outputVariable === variable);
                  const label = apiSource ? `${variable} (${apiSource.name})` :
                               modelSource ? `${variable} (${modelSource.name})` :
                               variable;
                  return (
                    <option key={variable} value={variable}>{label}</option>
                  );
                })}
              </select>
              <div className="mt-2">
                <Input
                  placeholder="Or enter custom value"
                  value={formData.leftOperand}
                  onChange={(e) => setFormData({...formData, leftOperand: e.target.value})}
                />
              </div>
            </div>
            <div>
              <Label htmlFor="operator">Operator</Label>
              <select
                value={formData.operator}
                onChange={(e) => setFormData({...formData, operator: e.target.value as any})}
                className="flex h-10 w-full rounded-md border border-gray-600 bg-gray-800 px-3 py-2 text-sm text-white focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent disabled:cursor-not-allowed disabled:opacity-50"
              >
                <option value="==">=  (equals)</option>
                <option value="!=">!=  (not equals)</option>
                <option value=">">&gt;  (greater than) 🔢</option>
                <option value="<">&lt;  (less than) 🔢</option>
                <option value=">=">&gt;=  (greater or equal) 🔢</option>
                <option value="<=">&lt;=  (less or equal) 🔢</option>
                <option value="contains">contains (text)</option>
                <option value="startsWith">starts with (text)</option>
                <option value="endsWith">ends with (text)</option>
              </select>
              {isNumericOperator(formData.operator) && (
                <div className="mt-1">
                  {numericVariables.length > 0 ? (
                    <p className="text-xs text-green-400">
                      ✅ Numeric variables available: {numericVariables.join(', ')}
                    </p>
                  ) : (
                    <p className="text-xs text-yellow-400">
                      ⚠️ No numeric variables available. Add API calls with "Cast to Number" enabled.
                    </p>
                  )}
                </div>
              )}
            </div>
            <div>
              <Label htmlFor="rightOperand">Right Operand</Label>
              <Input
                id="rightOperand"
                value={formData.rightOperand}
                onChange={(e) => setFormData({...formData, rightOperand: e.target.value})}
                placeholder={
                  ['>', '<', '>=', '<='].includes(formData.operator) ? 'e.g., 50000' :
                  ['contains', 'startsWith', 'endsWith'].includes(formData.operator) ? 'e.g., "Bitcoin"' :
                  'Value to compare'
                }
                type={isNumericOperator(formData.operator) ? 'number' : 'text'}
              />
              {isNumericOperator(formData.operator) && formData.rightOperand && (
                <div className="mt-1">
                  {isNaN(Number(formData.rightOperand)) ? (
                    <p className="text-xs text-red-400">
                      ❌ Must be a valid number for numeric comparison
                    </p>
                  ) : (
                    <p className="text-xs text-green-400">
                      ✅ Valid number: {Number(formData.rightOperand)}
                    </p>
                  )}
                </div>
              )}
              <div className="mt-1">
                <select
                  value=""
                  onChange={(e) => e.target.value && setFormData({...formData, rightOperand: e.target.value})}
                  className="flex h-8 w-full rounded-md border border-gray-600 bg-gray-800 px-2 py-1 text-xs text-white focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent disabled:cursor-not-allowed disabled:opacity-50"
                >
                  <option value="">Or select variable</option>
                  {(isNumericOperator(formData.operator) ? numericVariables : availableVariables).map(variable => (
                    <option key={variable} value={variable}>{variable}</option>
                  ))}
                </select>
                {isNumericOperator(formData.operator) && (
                  <p className="text-xs text-gray-400 mt-1">
                    Only numeric variables shown for numeric comparison
                  </p>
                )}
              </div>
            </div>
          </div>

          <div className="grid grid-cols-2 gap-4">
            <div>
              <Label htmlFor="trueOutputVariable">True Output Variable (optional)</Label>
              <Input
                id="trueOutputVariable"
                value={formData.trueOutputVariable || ''}
                onChange={(e) => setFormData({...formData, trueOutputVariable: e.target.value || undefined})}
                placeholder="highPrice"
              />
              <p className="text-xs text-gray-400 mt-1">
                Variable created when condition is TRUE (connects to green handle)
              </p>
            </div>
            <div>
              <Label htmlFor="falseOutputVariable">False Output Variable (optional)</Label>
              <Input
                id="falseOutputVariable"
                value={formData.falseOutputVariable || ''}
                onChange={(e) => setFormData({...formData, falseOutputVariable: e.target.value || undefined})}
                placeholder="lowPrice"
              />
              <p className="text-xs text-gray-400 mt-1">
                Variable created when condition is FALSE (connects to red handle)
              </p>
            </div>
          </div>

          <div className="grid grid-cols-2 gap-4">
            <div>
              <Label htmlFor="orderIndex">Order</Label>
              <Input
                id="orderIndex"
                type="number"
                value={formData.orderIndex}
                onChange={(e) => setFormData({...formData, orderIndex: parseInt(e.target.value)})}
                className="h-8"
              />
            </div>
            <div className="flex items-center space-x-2">
              <input
                type="checkbox"
                checked={formData.enabled}
                onChange={(e) => setFormData({...formData, enabled: e.target.checked})}
                className="rounded"
              />
              <Label className="text-white">Enabled</Label>
            </div>
          </div>

          {/* Flow Connection Guide */}
          <div className="bg-blue-900/20 border border-blue-700 rounded-lg p-4">
            <Label className="text-blue-300">💡 Flow Connection Guide</Label>
            <div className="text-sm text-blue-200 mt-2 space-y-1">
              <div className="flex items-center space-x-2">
                <div className="w-3 h-3 bg-green-400 rounded-full"></div>
                <span>Connect GREEN handle to nodes that run when condition is TRUE</span>
              </div>
              <div className="flex items-center space-x-2">
                <div className="w-3 h-3 bg-red-400 rounded-full"></div>
                <span>Connect RED handle to nodes that run when condition is FALSE</span>
              </div>
              <div className="text-xs text-blue-300 mt-2">
                💡 Tip: Drag from the colored handles on the right side of the condition node to create different paths
              </div>
            </div>
          </div>

          {/* Condition Preview */}
          {formData.leftOperand && formData.operator && formData.rightOperand && (
            <div className="bg-gray-800 border border-gray-600 rounded-lg p-4">
              <Label className="text-white">Condition Preview</Label>
              <div className="text-sm text-gray-300 mt-2 font-mono">
                <span className="text-blue-300">{formData.leftOperand}</span>
                <span className="text-yellow-300 mx-2">{formData.operator}</span>
                <span className="text-green-300">{formData.rightOperand}</span>
              </div>
              <div className="text-xs text-gray-400 mt-2">
                <div className="flex items-center space-x-1">
                  <div className="w-2 h-2 bg-green-400 rounded-full"></div>
                  <span>If TRUE → Variable: <span className="text-green-400">{formData.trueOutputVariable || 'condition_result'}</span></span>
                </div>
                <div className="flex items-center space-x-1">
                  <div className="w-2 h-2 bg-red-400 rounded-full"></div>
                  <span>If FALSE → Variable: <span className="text-red-400">{formData.falseOutputVariable || 'condition_result'}</span></span>
                </div>
              </div>
            </div>
          )}

          <div className="flex justify-between pt-4">
            <div>
              {conditionNode.id && onDelete && (
                <Button 
                  variant="outline" 
                  onClick={() => {
                    if (window.confirm('Are you sure you want to delete this condition node?')) {
                      onDelete();
                    }
                  }}
                  className="bg-red-600 hover:bg-red-700 text-white"
                >
                  <TrashIcon className="w-4 h-4 mr-2" />
                  Delete
                </Button>
              )}
            </div>
            <div className="flex space-x-2">
              <Button variant="outline" onClick={onCancel}>Cancel</Button>
              <Button onClick={() => onSave(formData)}>Save</Button>
            </div>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}

// Strategy Trigger Node Editor Component
function StrategyTriggerNodeEditor({ 
  triggerNode, 
  onSave, 
  onCancel, 
  onDelete, 
  availableStrategies, 
  availableVariables 
}: { 
  triggerNode: StrategyTriggerNode; 
  onSave: (triggerNode: StrategyTriggerNode) => void; 
  onCancel: () => void;
  onDelete?: () => void;
  availableStrategies: Strategy[];
  availableVariables: string[];
}) {
  const [formData, setFormData] = useState(triggerNode);

  // Add ESC key handler for strategy trigger node editor
  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (event.key === 'Escape') {
        onCancel();
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => {
      document.removeEventListener('keydown', handleKeyDown);
    };
  }, [onCancel]);

  return (
    <div className="fixed inset-0 z-60 bg-black/80 backdrop-blur-sm flex items-center justify-center p-4">
      <Card className="w-full max-w-2xl">
        <CardHeader>
          <CardTitle className="text-white">
            {triggerNode.id ? 'Edit Strategy Trigger' : 'New Strategy Trigger'}
          </CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="grid grid-cols-2 gap-4">
            <div>
              <Label htmlFor="name">Name</Label>
              <Input
                id="name"
                value={formData.name}
                onChange={(e) => setFormData({...formData, name: e.target.value})}
                placeholder="Trigger Alert Strategy"
              />
            </div>
            <div>
              <Label htmlFor="targetStrategyId">Target Strategy ID</Label>
              <select
                value={formData.targetStrategyId}
                onChange={(e) => setFormData({...formData, targetStrategyId: Number(e.target.value)})}
                className="flex h-10 w-full rounded-md border border-gray-600 bg-gray-800 px-3 py-2 text-sm text-white focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent disabled:cursor-not-allowed disabled:opacity-50"
              >
                <option value="">Select a strategy</option>
                {availableStrategies.map(strategy => (
                  <option key={strategy.id} value={strategy.id}>{strategy.name}</option>
                ))}
              </select>
            </div>
          </div>

          <div>
            <Label htmlFor="conditionVariable">Condition Variable (optional)</Label>
            <select
              value={formData.conditionVariable || ''}
              onChange={(e) => setFormData({...formData, conditionVariable: e.target.value || undefined})}
              className="flex h-10 w-full rounded-md border border-gray-600 bg-gray-800 px-3 py-2 text-sm text-white focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent disabled:cursor-not-allowed disabled:opacity-50"
            >
              <option value="">Select a variable</option>
              {availableVariables.map(variable => (
                <option key={variable} value={variable}>{variable}</option>
              ))}
            </select>
            <p className="text-xs text-gray-400 mt-1">
              Only trigger if this variable is truthy. Leave empty to always trigger.
            </p>
          </div>

          <div>
            <Label htmlFor="passVariables">Variables to Pass (comma-separated)</Label>
            <Input
              id="passVariables"
              value={formData.passVariables?.join(', ') || ''}
              onChange={(e) => setFormData({...formData, passVariables: e.target.value ? e.target.value.split(',').map(v => v.trim()) : []})}
              placeholder="btcPrice, analysis"
            />
          </div>

          <div className="grid grid-cols-2 gap-4">
            <div>
              <Label htmlFor="orderIndex">Order</Label>
              <Input
                id="orderIndex"
                type="number"
                value={formData.orderIndex}
                onChange={(e) => setFormData({...formData, orderIndex: parseInt(e.target.value)})}
                className="h-8"
              />
            </div>
            <div>
              <Label htmlFor="outputVariable">Output Variable (if waiting)</Label>
              <Input
                id="outputVariable"
                value={formData.outputVariable || ''}
                onChange={(e) => setFormData({...formData, outputVariable: e.target.value || undefined})}
                placeholder="triggerResult"
                disabled={!formData.waitForCompletion}
              />
            </div>
          </div>

          <div className="grid grid-cols-2 gap-4">
            <div className="flex items-center space-x-2">
              <input
                type="checkbox"
                id="waitForCompletion"
                checked={formData.waitForCompletion}
                onChange={(e) => setFormData({...formData, waitForCompletion: e.target.checked})}
                className="rounded"
              />
              <Label htmlFor="waitForCompletion">Wait for completion</Label>
            </div>
            <div className="flex items-center space-x-2">
              <input
                type="checkbox"
                checked={formData.enabled}
                onChange={(e) => setFormData({...formData, enabled: e.target.checked})}
                className="rounded"
              />
              <Label className="text-white">Enabled</Label>
            </div>
          </div>

          <div className="flex justify-between pt-4">
            <div>
              {triggerNode.id && (
                <Button 
                  variant="outline" 
                  onClick={() => {
                    // We need to add a delete handler here
                    if (window.confirm('Are you sure you want to delete this strategy trigger?')) {
                      // The delete handler will be passed down
                      if (onDelete) {
                        onDelete(); // Close modal first
                      }
                    }
                  }}
                  className="bg-red-600 hover:bg-red-700 text-white"
                >
                  <TrashIcon className="w-4 h-4 mr-2" />
                  Delete
                </Button>
              )}
            </div>
            <div className="flex space-x-2">
              <Button variant="outline" onClick={onCancel}>Cancel</Button>
              <Button onClick={() => onSave(formData)}>Save</Button>
            </div>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}

// Telegram Message Node Editor Component
function TelegramMessageNodeEditor({ 
  telegramNode, 
  onSave, 
  onCancel, 
  onDelete 
}: { 
  telegramNode: TelegramMessageNode; 
  onSave: (telegramNode: TelegramMessageNode) => void; 
  onCancel: () => void;
  onDelete?: () => void;
}) {
  const [formData, setFormData] = useState(telegramNode);

  // Add ESC key handler for telegram message node editor
  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (event.key === 'Escape') {
        onCancel();
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => {
      document.removeEventListener('keydown', handleKeyDown);
    };
  }, [onCancel]);

  return (
    <div className="fixed inset-0 z-60 bg-black/80 backdrop-blur-sm flex items-center justify-center p-4">
      <Card className="w-full max-w-2xl">
        <CardHeader>
          <CardTitle className="text-white">
            {telegramNode.id ? 'Edit Telegram Message' : 'New Telegram Message'}
          </CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="grid grid-cols-2 gap-4">
            <div>
              <Label htmlFor="name">Name</Label>
              <Input
                id="name"
                value={formData.name}
                onChange={(e) => setFormData({...formData, name: e.target.value})}
                placeholder="Alert Message"
              />
            </div>
            <div>
              <Label htmlFor="chatId">Chat ID</Label>
              <Input
                id="chatId"
                value={formData.chatId}
                onChange={(e) => setFormData({...formData, chatId: e.target.value})}
                placeholder="-100123456789"
              />
            </div>
          </div>

          <div>
            <Label htmlFor="messageTemplate">Message Template</Label>
            <Textarea
              id="messageTemplate"
              value={formData.messageTemplate}
              onChange={(e) => setFormData({...formData, messageTemplate: e.target.value})}
              placeholder="🚨 Alert: {signal} for {symbol}"
              className="h-24"
            />
          </div>

          <div className="grid grid-cols-2 gap-4">
            <div>
              <Label htmlFor="orderIndex">Order</Label>
              <Input
                id="orderIndex"
                type="number"
                value={formData.orderIndex}
                onChange={(e) => setFormData({...formData, orderIndex: parseInt(e.target.value)})}
                className="h-8"
              />
            </div>
            <div>
              <Label htmlFor="messageType">Message Type</Label>
              <select
                value={formData.messageType}
                onChange={(e) => setFormData({...formData, messageType: e.target.value as any})}
                className="flex h-10 w-full rounded-md border border-gray-600 bg-gray-800 px-3 py-2 text-sm text-white focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent disabled:cursor-not-allowed disabled:opacity-50"
              >
                <option value="info">Info</option>
                <option value="success">Success</option>
                <option value="warning">Warning</option>
                <option value="error">Error</option>
              </select>
            </div>
          </div>

          <div className="grid grid-cols-2 gap-4">
            <div className="flex items-center space-x-2">
              <input
                type="checkbox"
                checked={formData.includeApiData}
                onChange={(e) => setFormData({...formData, includeApiData: e.target.checked})}
                className="rounded"
              />
              <Label className="text-white">Include API Data</Label>
            </div>
            <div className="flex items-center space-x-2">
              <input
                type="checkbox"
                checked={formData.enabled}
                onChange={(e) => setFormData({...formData, enabled: e.target.checked})}
                className="rounded"
              />
              <Label className="text-white">Enabled</Label>
            </div>
          </div>

          <div>
            <Label htmlFor="onlyIfVariable">Only if Variable (optional)</Label>
            <Input
              id="onlyIfVariable"
              value={formData.onlyIfVariable || ''}
              onChange={(e) => setFormData({...formData, onlyIfVariable: e.target.value || undefined})}
              placeholder="highRisk"
            />
          </div>

          <div className="flex justify-between pt-4">
            <div>
              {telegramNode.id && onDelete && (
                <Button 
                  variant="outline" 
                  onClick={() => {
                    if (window.confirm('Are you sure you want to delete this telegram message?')) {
                      onDelete();
                    }
                  }}
                  className="bg-red-600 hover:bg-red-700 text-white"
                >
                  <TrashIcon className="w-4 h-4 mr-2" />
                  Delete
                </Button>
              )}
            </div>
            <div className="flex space-x-2">
              <Button variant="outline" onClick={onCancel}>Cancel</Button>
              <Button onClick={() => onSave(formData)}>Save</Button>
            </div>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}

// Strategy Settings Editor Component
function StrategySettingsEditor({ 
  strategy, 
  onSave, 
  onCancel 
}: { 
  strategy: any; 
  onSave: (strategyData: any) => void; 
  onCancel: () => void;
}) {
  const [formData, setFormData] = useState(strategy);

  // Add ESC key handler for strategy settings editor
  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (event.key === 'Escape') {
        onCancel();
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => {
      document.removeEventListener('keydown', handleKeyDown);
    };
  }, [onCancel]);

  const handleSave = () => {
    onSave(formData);
  };

  return (
    <div className="fixed inset-0 z-60 bg-black/80 backdrop-blur-sm flex items-center justify-center p-4">
      <Card className="w-full max-w-2xl">
        <CardHeader>
          <CardTitle className="text-white">Strategy Settings</CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          <div>
            <Label htmlFor="name">Name</Label>
            <Input
              id="name"
              value={formData.name}
              onChange={(e) => setFormData({...formData, name: e.target.value})}
            />
          </div>
          <div>
            <Label htmlFor="description">Description</Label>
            <Textarea
              id="description"
              value={formData.description || ''}
              onChange={(e) => setFormData({...formData, description: e.target.value})}
            />
          </div>
          <div>
            <Label htmlFor="cron">Cron Schedule (optional)</Label>
            <Input
              id="cron"
              value={formData.cron || ''}
              onChange={(e) => setFormData({...formData, cron: e.target.value})}
              placeholder="0 */5 * * * *"
            />
          </div>
          <div className="flex items-center space-x-2">
            <input
              type="checkbox"
              checked={formData.enabled}
              onChange={(e) => setFormData({...formData, enabled: e.target.checked})}
              className="rounded"
            />
            <Label className="text-white">Enabled</Label>
          </div>
          <div className="flex justify-end space-x-2 pt-4">
            <Button variant="outline" onClick={onCancel}>Cancel</Button>
            <Button onClick={handleSave}>Save</Button>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}

// Model Call Editor Component
function ModelCallEditor({ 
  modelCall, 
  onSave, 
  onCancel, 
  onDelete 
}: { 
  modelCall: ModelCall; 
  onSave: (modelCall: ModelCall) => void; 
  onCancel: () => void;
  onDelete?: () => void;
}) {
  const [formData, setFormData] = useState(modelCall);

  // Add ESC key handler for model call editor
  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (event.key === 'Escape') {
        onCancel();
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => {
      document.removeEventListener('keydown', handleKeyDown);
    };
  }, [onCancel]);

  return (
    <div className="fixed inset-0 z-60 bg-black/80 backdrop-blur-sm flex items-center justify-center p-4">
      <Card className="w-full max-w-2xl max-h-[80vh] overflow-y-auto">
        <CardHeader>
          <CardTitle className="text-white">
            {modelCall.id ? 'Edit Model Call' : 'Create Model Call'}
          </CardTitle>
        </CardHeader>
        <CardContent className="space-y-3">
          <div className="grid grid-cols-4 items-center gap-4">
            <Label htmlFor="name" className="text-right text-white">Name</Label>
            <Input
              id="name"
              value={formData.name}
              onChange={(e) => setFormData({...formData, name: e.target.value})}
              className="col-span-3 h-8"
            />
          </div>
          <div className="grid grid-cols-4 items-center gap-4">
            <Label htmlFor="modelTier" className="text-right text-white">Model Tier</Label>
            <select
              value={formData.modelTier}
              onChange={(e) => setFormData({...formData, modelTier: e.target.value as 'cheap' | 'deep'})}
              className="col-span-3 h-8 rounded-md border border-gray-600 bg-gray-800 px-3 text-sm text-white"
            >
              <option value="cheap">Cheap</option>
              <option value="deep">Deep</option>
            </select>
          </div>
          <div className="grid grid-cols-4 items-center gap-4">
            <Label htmlFor="systemPrompt" className="text-right text-white">System Prompt</Label>
            <Textarea
              id="systemPrompt"
              value={formData.systemPrompt || ''}
              onChange={(e) => setFormData({...formData, systemPrompt: e.target.value})}
              className="col-span-3 h-16"
            />
          </div>
          <div className="grid grid-cols-4 items-center gap-4">
            <Label htmlFor="userPrompt" className="text-right text-white">User Prompt</Label>
            <Textarea
              id="userPrompt"
              value={formData.userPrompt}
              onChange={(e) => setFormData({...formData, userPrompt: e.target.value})}
              className="col-span-3 h-16"
            />
          </div>
          <div className="grid grid-cols-4 items-center gap-4">
            <Label htmlFor="outputVariable" className="text-right text-white">Output Variable</Label>
            <Input
              id="outputVariable"
              value={formData.outputVariable}
              onChange={(e) => setFormData({...formData, outputVariable: e.target.value})}
              className="col-span-3 h-8"
            />
          </div>
          <div className="grid grid-cols-4 items-center gap-4">
            <Label htmlFor="orderIndex" className="text-right text-white">Order</Label>
            <Input
              id="orderIndex"
              type="number"
              value={formData.orderIndex}
              onChange={(e) => setFormData({...formData, orderIndex: parseInt(e.target.value)})}
              className="col-span-3 h-8"
            />
          </div>
          <div className="grid grid-cols-2 gap-4">
            <div className="flex items-center space-x-2">
              <input
                type="checkbox"
                checked={formData.includeApiData}
                onChange={(e) => setFormData({...formData, includeApiData: e.target.checked})}
                className="rounded"
              />
              <Label className="text-white">Include API Data</Label>
            </div>
            <div className="flex items-center space-x-2">
              <input
                type="checkbox"
                checked={formData.enabled}
                onChange={(e) => setFormData({...formData, enabled: e.target.checked})}
                className="rounded"
              />
              <Label className="text-white">Enabled</Label>
            </div>
          </div>
          <div className="flex justify-between pt-4">
            <div>
              {modelCall.id && onDelete && (
                <Button 
                  variant="outline" 
                  onClick={() => {
                    if (window.confirm('Are you sure you want to delete this model call?')) {
                      onDelete();
                    }
                  }}
                  className="bg-red-600 hover:bg-red-700 text-white"
                >
                  <TrashIcon className="w-4 h-4 mr-2" />
                  Delete
                </Button>
              )}
            </div>
            <div className="flex space-x-2">
              <Button variant="outline" onClick={onCancel}>
                Cancel
              </Button>
              <Button onClick={() => onSave(formData)}>
                {modelCall.id ? 'Update' : 'Create'}
              </Button>
            </div>
          </div>
        </CardContent>
      </Card>
    </div>
  );
} 

// API Call Editor Component
function ApiCallEditor({ 
  apiCall, 
  onSave, 
  onCancel, 
  onDelete,
  testResult,
  testing,
  onTest
}: { 
  apiCall: ApiCall; 
  onSave: (apiCall: ApiCall) => void; 
  onCancel: () => void;
  onDelete?: () => void;
  testResult: any;
  testing: boolean;
  onTest: (apiCall: ApiCall) => void;
}) {
  const [formData, setFormData] = useState(apiCall);

  // Add ESC key handler for API call editor
  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (event.key === 'Escape') {
        onCancel();
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => {
      document.removeEventListener('keydown', handleKeyDown);
    };
  }, [onCancel]);

  return (
    <div className="fixed inset-0 z-60 bg-black/80 backdrop-blur-sm flex items-center justify-center p-4">
      <Card className="w-full max-w-4xl max-h-[80vh] overflow-y-auto">
        <CardHeader>
          <CardTitle className="text-white">
            {apiCall.id ? 'Edit API Call' : 'Create API Call'}
          </CardTitle>
        </CardHeader>
        <CardContent className="space-y-3">
          <div className="grid grid-cols-2 gap-4">
            <div>
              <Label htmlFor="name" className="text-white">Name</Label>
              <Input
                id="name"
                value={formData.name}
                onChange={(e) => setFormData({...formData, name: e.target.value})}
                className="h-8"
              />
            </div>
            <div>
              <Label htmlFor="method" className="text-white">Method</Label>
              <select
                value={formData.method}
                onChange={(e) => setFormData({...formData, method: e.target.value})}
                className="h-8 w-full rounded-md border border-gray-600 bg-gray-800 px-3 text-sm text-white"
              >
                <option value="GET">GET</option>
                <option value="POST">POST</option>
                <option value="PUT">PUT</option>
                <option value="DELETE">DELETE</option>
              </select>
            </div>
          </div>
          
          <div>
            <Label htmlFor="url" className="text-white">URL</Label>
            <Input
              id="url"
              value={formData.url}
              onChange={(e) => setFormData({...formData, url: e.target.value})}
              className="h-8"
            />
          </div>

          <div className="grid grid-cols-2 gap-4">
            <div>
              <Label htmlFor="outputVariable" className="text-white">Output Variable</Label>
              <Input
                id="outputVariable"
                value={formData.outputVariable}
                onChange={(e) => setFormData({...formData, outputVariable: e.target.value})}
                className="h-8"
              />
            </div>
            <div>
              <Label htmlFor="orderIndex" className="text-white">Order</Label>
              <Input
                id="orderIndex"
                type="number"
                value={formData.orderIndex}
                onChange={(e) => setFormData({...formData, orderIndex: parseInt(e.target.value)})}
                className="h-8"
              />
            </div>
          </div>

          <div className="flex items-center space-x-2">
            <input
              type="checkbox"
              checked={formData.enabled}
              onChange={(e) => setFormData({...formData, enabled: e.target.checked})}
              className="rounded"
            />
            <Label className="text-white">Enabled</Label>
          </div>

          {/* Test Section */}
          <div className="border-t border-gray-600 pt-4">
            <div className="flex items-center justify-between mb-3">
              <Label className="text-white text-lg">Test API Call</Label>
              <Button 
                onClick={() => onTest(formData)}
                disabled={testing || !formData.url}
                className="bg-blue-600 hover:bg-blue-700"
              >
                {testing ? (
                  <div className="w-4 h-4 animate-spin rounded-full border-2 border-gray-300 border-t-blue-600 mr-2"></div>
                ) : (
                  <TestTubeIcon className="w-4 h-4 mr-2" />
                )}
                {testing ? 'Testing...' : 'Test Call'}
              </Button>
            </div>

            {testResult && (
              <div className="bg-gray-800 border border-gray-600 rounded-lg p-4 mb-4">
                <div className="flex items-center space-x-2 mb-3">
                  {testResult.success ? (
                    <CheckIcon className="w-5 h-5 text-green-400" />
                  ) : (
                    <XMarkIcon className="w-5 h-5 text-red-400" />
                  )}
                  <span className="text-white font-medium">
                    Test Result {testResult.success ? '✅' : '❌'}
                  </span>
                </div>

                {testResult.success ? (
                  <div className="space-y-3">
                    {/* JSON Path Configuration */}
                    <div>
                      <Label htmlFor="jsonPath" className="text-white">JSON Path (optional)</Label>
                      <div className="flex space-x-2">
                        <Input
                          id="jsonPath"
                          value={formData.jsonPath || ''}
                          onChange={(e) => setFormData({...formData, jsonPath: e.target.value})}
                          placeholder="$.data.price"
                          className="h-8 flex-1"
                        />
                        <Button 
                          onClick={() => onTest(formData)}
                          size="sm"
                          className="bg-gray-600 hover:bg-gray-700"
                        >
                          Preview
                        </Button>
                      </div>
                      <p className="text-xs text-gray-400 mt-1">
                        Leave empty to store the full response. Use JSON path to extract specific values.
                      </p>
                    </div>

                    {/* Number Casting Toggle */}
                    <div>
                      <div className="flex items-center space-x-3">
                        <input
                          type="checkbox"
                          id="castToNumber"
                          checked={formData.castToNumber || false}
                          onChange={(e) => setFormData({...formData, castToNumber: e.target.checked})}
                          className="rounded border-gray-600 bg-gray-800 text-blue-500 focus:ring-blue-500"
                        />
                        <Label htmlFor="castToNumber" className="text-white cursor-pointer">
                          🔢 Cast to Number
                        </Label>
                      </div>
                      <p className="text-xs text-gray-400 mt-1">
                        Enable this to convert the extracted value to a number. This allows you to use it in numeric conditions.
                      </p>
                      {formData.castToNumber && (
                        <div className="bg-blue-900/20 border border-blue-700 rounded p-2 mt-2">
                          <p className="text-xs text-blue-200">
                            ✅ This variable will be available for numeric comparisons ({">"}，{"<"}，{">="}，{"<="}) in condition nodes.
                          </p>
                        </div>
                      )}
                    </div>

                    {/* Response preview */}
                    <div className="space-y-2">
                      <Label className="text-white text-sm">Response Data:</Label>
                      <div className="bg-gray-900 rounded p-3 max-h-40 overflow-y-auto">
                        <pre className="text-xs text-green-400 whitespace-pre-wrap">
                          {JSON.stringify(testResult.data, null, 2)}
                        </pre>
                      </div>
                      
                      {formData.jsonPath && (
                        <div className="space-y-2">
                          <Label className="text-white text-sm">Extracted Value:</Label>
                          <div className="bg-gray-900 rounded p-3">
                            <pre className="text-xs text-yellow-400">
                              {testResult.extractedValue !== undefined ? 
                                JSON.stringify(testResult.extractedValue, null, 2) : 
                                'No value found at this path'
                              }
                            </pre>
                          </div>
                          {formData.castToNumber && testResult.extractedValue !== undefined && (
                            <div className="bg-gray-900 rounded p-3">
                              <Label className="text-white text-sm">As Number:</Label>
                              <pre className="text-xs text-blue-400">
                                {isNaN(Number(testResult.extractedValue)) ? 
                                  '❌ Cannot convert to number' : 
                                  `✅ ${Number(testResult.extractedValue)}`
                                }
                              </pre>
                            </div>
                          )}
                        </div>
                      )}
                    </div>
                  </div>
                ) : (
                  <div className="space-y-2">
                    <Label className="text-white text-sm">Error:</Label>
                    <div className="bg-red-900/20 border border-red-600 rounded p-3">
                      <pre className="text-xs text-red-400 whitespace-pre-wrap">
                        {testResult.error}
                      </pre>
                    </div>
                  </div>
                )}
              </div>
            )}
          </div>

          <div className="flex justify-between pt-4">
            <div>
              {apiCall.id && onDelete && (
                <Button 
                  variant="outline" 
                  onClick={() => {
                    if (window.confirm('Are you sure you want to delete this API call?')) {
                      onDelete();
                    }
                  }}
                  className="bg-red-600 hover:bg-red-700 text-white"
                >
                  <TrashIcon className="w-4 h-4 mr-2" />
                  Delete
                </Button>
              )}
            </div>
            <div className="flex space-x-2">
              <Button variant="outline" onClick={onCancel}>
                Cancel
              </Button>
              <Button onClick={() => onSave(formData)}>
                {apiCall.id ? 'Update' : 'Create'}
              </Button>
            </div>
          </div>
        </CardContent>
      </Card>
    </div>
  );
} 