import {
  ArrowPathIcon,
  CpuChipIcon as BrainIcon,
  ChatBubbleLeftIcon,
  CheckIcon,
  PencilIcon as EditIcon,
  GlobeAltIcon as GlobeIcon,
  InformationCircleIcon,
  PlayIcon,
  PlusIcon,
  BeakerIcon as TestTubeIcon,
  TrashIcon,
  XMarkIcon
} from '@heroicons/react/24/outline';
import { useCallback, useEffect, useState } from 'react';
import ReactFlow, {
  addEdge,
  Background,
  BackgroundVariant,
  Connection,
  ConnectionLineType,
  Controls,
  Edge,
  Handle,
  Node,
  NodeTypes,
  Position,
  useEdgesState,
  useNodesState
} from 'reactflow';
import 'reactflow/dist/style.css';
import { Strategy, useApi } from '../services/websocketService';
import { Button } from './ui/button';
import { Card, CardContent, CardHeader, CardTitle } from './ui/card';
import { Input } from './ui/input';
import { Label } from './ui/label';
import { Textarea } from './ui/textarea';

interface StrategyFlowEditorProps {
  strategyId: number;
  onClose: () => void;
  onRefetch?: () => Promise<void>;
}

interface ApiCall {
  id?: number;
  name: string;
  url: string;
  method: string;
  headers?: string;
  body?: string;
  jsonPath?: string;
  outputVariable: string;
  orderIndex: number;
  enabled: boolean;
}

interface ModelCall {
  id?: number;
  name: string;
  modelTier: 'cheap' | 'deep';
  systemPrompt?: string;
  userPrompt: string;
  includeApiData: boolean;
  outputVariable: string;
  orderIndex: number;
  enabled: boolean;
}

interface ConditionNode {
  id?: number;
  name: string;
  conditionType: 'api_result' | 'model_response' | 'variable_value';
  leftOperand: string;
  operator: '==' | '!=' | '>' | '<' | '>=' | '<=' | 'contains' | 'startsWith' | 'endsWith';
  rightOperand: string;
  trueOutputVariable?: string;
  falseOutputVariable?: string;
  orderIndex: number;
  enabled: boolean;
}

interface StrategyTriggerNode {
  id?: number;
  name: string;
  targetStrategyId: number;
  conditionVariable?: string;
  passVariables?: string[];
  waitForCompletion: boolean;
  outputVariable?: string;
  orderIndex: number;
  enabled: boolean;
}

interface TelegramMessageNode {
  id?: number;
  name: string;
  chatId: string;
  messageTemplate: string;
  includeApiData: boolean;
  onlyIfVariable?: string;
  messageType: 'info' | 'success' | 'warning' | 'error';
  parseMode?: 'Markdown' | 'HTML' | 'none';
  orderIndex: number;
  enabled: boolean;
}

// Custom Node Components
const StartNode = ({ data }: { data: any }) => {
  return (
    <div 
      className="bg-green-600 border-2 border-green-500 rounded-lg p-3 text-white w-[200px] h-[80px] cursor-pointer hover:bg-green-700 transition-colors flex flex-col justify-center"
      onClick={() => data.onEdit?.(data)}
      title={`${data.name}\n${data.description || 'Strategy begins here'}\n${data.cron ? `Schedule: ${data.cron}` : 'Manual trigger only'}`}
    >
      <div className="flex items-center space-x-2">
        <PlayIcon className="w-4 h-4 flex-shrink-0" />
        <div className="flex-1 min-w-0">
          <div className="font-semibold text-sm truncate">START</div>
          <div className="text-xs text-green-200 truncate">{data.name}</div>
        </div>
      </div>
      <Handle
        type="source"
        position={Position.Right}
        className="w-3 h-3 bg-green-400 border-2 border-green-300"
      />
    </div>
  );
};

const ApiCallNode = ({ data }: { data: any }) => {
  return (
    <div 
      className="bg-blue-600 border-2 border-blue-500 rounded-lg p-3 text-white w-[200px] h-[80px] cursor-pointer hover:bg-blue-700 transition-colors flex flex-col justify-center"
      onClick={() => data.onEdit?.(data)}
      title={`${data.name}\n${data.method} ${data.url}\nOutput: ${data.outputVariable}\n${data.enabled ? 'Enabled' : 'Disabled'}`}
    >
      <Handle
        type="target"
        position={Position.Left}
        className="w-3 h-3 bg-blue-400 border-2 border-blue-300"
      />
      <div className="flex items-center space-x-2">
        <GlobeIcon className="w-4 h-4 flex-shrink-0" />
        <div className="flex-1 min-w-0">
          <div className="font-medium text-sm truncate">{data.name}</div>
          <div className="text-xs text-blue-200 truncate">{data.method}</div>
        </div>
        <div className={`w-2 h-2 rounded-full flex-shrink-0 ${data.enabled ? 'bg-green-400' : 'bg-red-400'}`} />
      </div>
      <Handle
        type="source"
        position={Position.Right}
        className="w-3 h-3 bg-blue-400 border-2 border-blue-300"
      />
    </div>
  );
};

const ModelCallNode = ({ data }: { data: any }) => {
  return (
    <div 
      className="bg-purple-600 border-2 border-purple-500 rounded-lg p-3 text-white w-[200px] h-[80px] cursor-pointer hover:bg-purple-700 transition-colors flex flex-col justify-center"
      onClick={() => data.onEdit?.(data)}
      title={`${data.name}\n${data.modelTier} model\n${data.includeApiData ? 'Includes API data' : 'Template only'}\nOutput: ${data.outputVariable}\n${data.enabled ? 'Enabled' : 'Disabled'}`}
    >
      <Handle
        type="target"
        position={Position.Left}
        className="w-3 h-3 bg-purple-400 border-2 border-purple-300"
      />
      <div className="flex items-center space-x-2">
        <BrainIcon className="w-4 h-4 flex-shrink-0" />
        <div className="flex-1 min-w-0">
          <div className="font-medium text-sm truncate">{data.name}</div>
          <div className="text-xs text-purple-200 truncate">{data.modelTier} model</div>
        </div>
        <div className={`w-2 h-2 rounded-full flex-shrink-0 ${data.enabled ? 'bg-green-400' : 'bg-red-400'}`} />
      </div>
      <Handle
        type="source"
        position={Position.Right}
        className="w-3 h-3 bg-purple-400 border-2 border-purple-300"
      />
    </div>
  );
};

const ConditionNode = ({ data }: { data: any }) => {
  return (
    <div 
      className="bg-yellow-600 border-2 border-yellow-500 rounded-lg p-3 text-white w-[200px] h-[80px] cursor-pointer hover:bg-yellow-700 transition-colors flex flex-col justify-center"
      onClick={() => data.onEdit?.(data)}
      title={`${data.name}\nCondition: ${data.leftOperand} ${data.operator} ${data.rightOperand}\nType: ${data.conditionType?.replace('_', ' ')}\n${data.enabled ? 'Enabled' : 'Disabled'}`}
    >
      <Handle
        type="target"
        position={Position.Left}
        className="w-3 h-3 bg-yellow-400 border-2 border-yellow-300"
      />
      <div className="flex items-center space-x-2">
        <InformationCircleIcon className="w-4 h-4 flex-shrink-0" />
        <div className="flex-1 min-w-0">
          <div className="font-medium text-sm truncate">{data.name}</div>
          <div className="text-xs text-yellow-200 truncate">Condition</div>
        </div>
        <div className={`w-2 h-2 rounded-full flex-shrink-0 ${data.enabled ? 'bg-green-400' : 'bg-red-400'}`} />
      </div>
      <Handle
        type="source"
        position={Position.Right}
        id="true"
        className="w-3 h-3 bg-green-400 border-2 border-green-300"
        style={{ top: '60%' }}
      />
      <Handle
        type="source"
        position={Position.Right}
        id="false"
        className="w-3 h-3 bg-red-400 border-2 border-red-300"
        style={{ top: '80%' }}
      />
    </div>
  );
};

const StrategyTriggerNode = ({ data }: { data: any }) => {
  return (
    <div 
      className="bg-orange-600 border-2 border-orange-500 rounded-lg p-3 text-white w-[200px] h-[80px] cursor-pointer hover:bg-orange-700 transition-colors flex flex-col justify-center"
      onClick={() => data.onEdit?.(data)}
      title={`${data.name}\nTarget: Strategy #${data.targetStrategyId}\n${data.waitForCompletion ? 'Wait for completion' : 'Fire & forget'}\n${data.conditionVariable ? `Condition: ${data.conditionVariable}` : 'Always trigger'}\n${data.enabled ? 'Enabled' : 'Disabled'}`}
    >
      <Handle
        type="target"
        position={Position.Left}
        className="w-3 h-3 bg-orange-400 border-2 border-orange-300"
      />
      <div className="flex items-center space-x-2">
        <ArrowPathIcon className="w-4 h-4 flex-shrink-0" />
        <div className="flex-1 min-w-0">
          <div className="font-medium text-sm truncate">{data.name}</div>
          <div className="text-xs text-orange-200 truncate">Trigger Strategy</div>
        </div>
        <div className={`w-2 h-2 rounded-full flex-shrink-0 ${data.enabled ? 'bg-green-400' : 'bg-red-400'}`} />
      </div>
      <Handle
        type="source"
        position={Position.Right}
        className="w-3 h-3 bg-orange-400 border-2 border-orange-300"
      />
    </div>
  );
};

const TelegramMessageNode = ({ data }: { data: any }) => {
  return (
    <div 
      className="bg-teal-600 border-2 border-teal-500 rounded-lg p-3 text-white w-[200px] h-[80px] cursor-pointer hover:bg-teal-700 transition-colors flex flex-col justify-center"
      onClick={() => data.onEdit?.(data)}
      title={`${data.name}\nChat: ${data.chatId}\nType: ${data.messageType} message\n${data.onlyIfVariable ? `Condition: ${data.onlyIfVariable}` : 'Always send'}\n${data.enabled ? 'Enabled' : 'Disabled'}`}
    >
      <Handle
        type="target"
        position={Position.Left}
        className="w-3 h-3 bg-teal-400 border-2 border-teal-300"
      />
      <div className="flex items-center space-x-2">
        <ChatBubbleLeftIcon className="w-4 h-4 flex-shrink-0" />
        <div className="flex-1 min-w-0">
          <div className="font-medium text-sm truncate">{data.name}</div>
          <div className="text-xs text-teal-200 truncate">Send to Telegram</div>
        </div>
        <div className={`w-2 h-2 rounded-full flex-shrink-0 ${data.enabled ? 'bg-green-400' : 'bg-red-400'}`} />
      </div>
      <Handle
        type="source"
        position={Position.Right}
        className="w-3 h-3 bg-teal-400 border-2 border-teal-300"
      />
    </div>
  );
};

const EndNode = ({ data }: { data: any }) => {
  return (
    <div 
      className="bg-red-700 border-2 border-red-600 rounded-lg p-3 text-white w-[200px] h-[80px] flex flex-col justify-center"
      title={`${data.name || 'End'}\n${data.description || 'Flow ends here'}`}
    >
      <Handle
        type="target"
        position={Position.Left}
        id="end-input"
        className="!bg-red-300 !border-red-600 !w-3 !h-3"
      />
      <div className="flex items-center space-x-2">
        <XMarkIcon className="w-4 h-4 text-red-100 flex-shrink-0" />
        <div className="flex-1 min-w-0">
          <div className="font-medium text-sm truncate">END</div>
          <div className="text-xs text-red-200 truncate">Flow ends here</div>
        </div>
      </div>
    </div>
  );
};

const nodeTypes: NodeTypes = {
  start: StartNode,
  apiCall: ApiCallNode,
  modelCall: ModelCallNode,
  condition: ConditionNode,
  strategyTrigger: StrategyTriggerNode,
  telegramMessage: TelegramMessageNode,
  end: EndNode,
};

// Add edge styles
const edgeOptions = {
  animated: true,
  style: { strokeWidth: 3 },
  type: 'smoothstep',
};

export default function StrategyFlowEditor({ strategyId, onClose, onRefetch }: StrategyFlowEditorProps) {
  const [apiCalls, setApiCalls] = useState<ApiCall[]>([]);
  const [modelCalls, setModelCalls] = useState<ModelCall[]>([]);
  const [conditionNodes, setConditionNodes] = useState<ConditionNode[]>([]);
  const [strategyTriggerNodes, setStrategyTriggerNodes] = useState<StrategyTriggerNode[]>([]);
  const [telegramMessageNodes, setTelegramMessageNodes] = useState<TelegramMessageNode[]>([]);
  const [loading, setLoading] = useState(true);
  const [selectedTab, setSelectedTab] = useState<'flow' | 'api' | 'model' | 'condition' | 'trigger' | 'telegram' | 'settings'>('flow');
  const [editingApiCall, setEditingApiCall] = useState<ApiCall | null>(null);
  const [editingModelCall, setEditingModelCall] = useState<ModelCall | null>(null);
  const [editingConditionNode, setEditingConditionNode] = useState<ConditionNode | null>(null);
  const [editingStrategyTriggerNode, setEditingStrategyTriggerNode] = useState<StrategyTriggerNode | null>(null);
  const [editingTelegramMessageNode, setEditingTelegramMessageNode] = useState<TelegramMessageNode | null>(null);
  const [testResult, setTestResult] = useState<any>(null);
  const [testing, setTesting] = useState(false);
  const [executionLogs, setExecutionLogs] = useState<any[]>([]);
  const [executing, setExecuting] = useState(false);
  const [strategy, setStrategy] = useState<any>(null);
  const [editingStrategy, setEditingStrategy] = useState<any>(null);
  const [availableStrategies, setAvailableStrategies] = useState<Strategy[]>([]);
  const [availableVariables, setAvailableVariables] = useState<string[]>([]);
  
  // React Flow states
  const [nodes, setNodes, onNodesChange] = useNodesState([]);
  const [edges, setEdges, onEdgesChange] = useEdgesState([]);
  
  const api = useApi();

  const onConnect = useCallback(
    (params: Connection) => setEdges((eds) => addEdge(params, eds)),
    [setEdges]
  );

  // Calculate available variables from the flow
  const getAvailableVariables = useCallback(() => {
    const variables: string[] = [];
    
    // Add variables from API calls
    apiCalls.forEach(apiCall => {
      if (apiCall.outputVariable) {
        variables.push(apiCall.outputVariable);
      }
    });
    
    // Add variables from model calls
    modelCalls.forEach(modelCall => {
      if (modelCall.outputVariable) {
        variables.push(modelCall.outputVariable);
      }
    });
    
    // Add variables from condition nodes
    conditionNodes.forEach(conditionNode => {
      if (conditionNode.trueOutputVariable) {
        variables.push(conditionNode.trueOutputVariable);
      }
      if (conditionNode.falseOutputVariable) {
        variables.push(conditionNode.falseOutputVariable);
      }
    });
    
    // Add variables from strategy trigger nodes
    strategyTriggerNodes.forEach(triggerNode => {
      if (triggerNode.outputVariable) {
        variables.push(triggerNode.outputVariable);
      }
    });
    
    return [...new Set(variables)]; // Remove duplicates
  }, [apiCalls, modelCalls, conditionNodes, strategyTriggerNodes]);

  // Update available variables when data changes
  useEffect(() => {
    setAvailableVariables(getAvailableVariables());
  }, [getAvailableVariables]);

  // Load available strategies
  const loadAvailableStrategies = async () => {
    const result = await api.getStrategies();
    if (result.success && result.data) {
      setAvailableStrategies(result.data.filter((s: Strategy) => s.id !== strategyId));
    }
  };

  useEffect(() => {
    if (strategyId) {
      loadStrategyFlow();
      loadStrategy();
      loadAvailableStrategies();
    }
  }, [strategyId]);

  // Update React Flow nodes when API/model calls change
  useEffect(() => {
    updateFlowNodes();
  }, [apiCalls, modelCalls, conditionNodes, strategyTriggerNodes, telegramMessageNodes, strategy]);

  // Debug edges
  useEffect(() => {
    console.log('🔗 Edges state updated:', edges.length, 'edges');
    console.log('🔗 Current edges:', edges);
  }, [edges]);

  // Helper functions to get handle IDs for edges - improved to support condition nodes
  const getSourceHandle = (nodeId: string, handleType?: 'true' | 'false'): string => {
    if (nodeId === 'start-node') return 'start-output';
    if (nodeId.startsWith('api-')) return 'api-output';
    if (nodeId.startsWith('model-')) return 'model-output';
    if (nodeId.startsWith('condition-')) {
      // For condition nodes, use the specific handle type
      if (handleType === 'true') return 'condition-true';
      if (handleType === 'false') return 'condition-false';
      return 'condition-true'; // Default to true handle for auto-generated edges
    }
    if (nodeId.startsWith('trigger-')) return 'trigger-output';
    if (nodeId.startsWith('telegram-')) return 'telegram-output';
    return 'default-output';
  };

  const getTargetHandle = (nodeId: string): string => {
    if (nodeId === 'start-node') return 'start-input';
    if (nodeId.startsWith('api-')) return 'api-input';
    if (nodeId.startsWith('model-')) return 'model-input';
    if (nodeId.startsWith('condition-')) return 'condition-input';
    if (nodeId.startsWith('trigger-')) return 'trigger-input';
    if (nodeId.startsWith('telegram-')) return 'telegram-input';
    return 'default-input';
  };

  const updateFlowNodes = () => {
    const newNodes: Node[] = [];
    const newEdges: Edge[] = [];

    // Constants for layout
    const NODE_WIDTH = 200;
    const NODE_HEIGHT = 80;
    const HORIZONTAL_SPACING = 280; // Space between columns
    const VERTICAL_SPACING = 120; // Space between parallel nodes
    const START_X = 0;
    const CENTER_Y = 250;

    // Start node
    const startNode: Node = {
      id: 'start',
      type: 'start',
      position: { x: START_X, y: CENTER_Y - NODE_HEIGHT / 2 },
      data: {
        name: strategy?.name || 'Strategy',
        description: strategy?.description,
        cron: strategy?.cron,
        onEdit: () => setEditingStrategy(strategy)
      }
    };
    newNodes.push(startNode);

    // Combine all steps for ordering
    const allSteps = [
      ...apiCalls.map(call => ({ ...call, type: 'api_call' as const })),
      ...modelCalls.map(call => ({ ...call, type: 'model_call' as const })),
      ...conditionNodes.map(node => ({ ...node, type: 'condition_node' as const })),
      ...strategyTriggerNodes.map(node => ({ ...node, type: 'strategy_trigger_node' as const })),
      ...telegramMessageNodes.map(node => ({ ...node, type: 'telegram_message_node' as const }))
    ].sort((a, b) => a.orderIndex - b.orderIndex);

    // Group steps by order index for parallel execution
    const stepGroups: { [orderIndex: number]: any[] } = {};
    allSteps.forEach(step => {
      if (!stepGroups[step.orderIndex]) {
        stepGroups[step.orderIndex] = [];
      }
      stepGroups[step.orderIndex].push(step);
    });

    const orderedIndices = Object.keys(stepGroups).map(Number).sort((a, b) => a - b);
    let previousNodeIds: string[] = ['start'];
    let currentX = START_X + HORIZONTAL_SPACING;

    orderedIndices.forEach((orderIndex, groupIndex) => {
      const group = stepGroups[orderIndex];
      const currentNodeIds: string[] = [];
      
      // Calculate positions for this group
      group.forEach((step, stepIndex) => {
        const nodeId = `${step.type}_${step.id}`;
        currentNodeIds.push(nodeId);
        
        // Calculate Y position for proper vertical distribution
        let nodeY;
        if (group.length === 1) {
          // Single node: center it
          nodeY = CENTER_Y - NODE_HEIGHT / 2;
        } else {
          // Multiple nodes: distribute them evenly
          const totalHeight = (group.length - 1) * VERTICAL_SPACING;
          const startY = CENTER_Y - totalHeight / 2 - NODE_HEIGHT / 2;
          nodeY = startY + (stepIndex * VERTICAL_SPACING);
        }
        
        const nodeData = {
          ...step,
          onEdit: () => {
            if (step.type === 'api_call') openApiCallEditor(step);
            else if (step.type === 'model_call') setEditingModelCall(step);
            else if (step.type === 'condition_node') setEditingConditionNode(step);
            else if (step.type === 'strategy_trigger_node') setEditingStrategyTriggerNode(step);
            else if (step.type === 'telegram_message_node') setEditingTelegramMessageNode(step);
          }
        };

        let nodeType = 'apiCall';
        if (step.type === 'model_call') nodeType = 'modelCall';
        else if (step.type === 'condition_node') nodeType = 'condition';
        else if (step.type === 'strategy_trigger_node') nodeType = 'strategyTrigger';
        else if (step.type === 'telegram_message_node') nodeType = 'telegramMessage';

        const node: Node = {
          id: nodeId,
          type: nodeType,
          position: { x: currentX, y: nodeY },
          data: nodeData
        };

        newNodes.push(node);
      });

      // Connect previous group to current group
      if (previousNodeIds.length > 0 && currentNodeIds.length > 0) {
        if (previousNodeIds.length === 1 && currentNodeIds.length === 1) {
          // Simple 1-to-1 connection
          newEdges.push({
            id: `${previousNodeIds[0]}-${currentNodeIds[0]}`,
            source: previousNodeIds[0],
            target: currentNodeIds[0],
            sourceHandle: getSourceHandle(previousNodeIds[0]),
            targetHandle: getTargetHandle(currentNodeIds[0])
          });
        } else {
          // Connect each previous node to each current node
          previousNodeIds.forEach(prevId => {
            currentNodeIds.forEach(currId => {
              newEdges.push({
                id: `${prevId}-${currId}`,
                source: prevId,
                target: currId,
                sourceHandle: getSourceHandle(prevId),
                targetHandle: getTargetHandle(currId)
              });
            });
          });
        }
      }

      previousNodeIds = currentNodeIds;
      currentX += HORIZONTAL_SPACING;
    });

    // Add end node if there are any steps
    if (allSteps.length > 0) {
      const endNode: Node = {
        id: 'end',
        type: 'end',
        position: { x: currentX, y: CENTER_Y - NODE_HEIGHT / 2 },
        data: {
          name: 'End',
          description: 'Flow ends here'
        }
      };
      newNodes.push(endNode);

      // Connect last group to end node
      if (previousNodeIds.length > 0) {
        previousNodeIds.forEach(nodeId => {
          newEdges.push({
            id: `${nodeId}-end`,
            source: nodeId,
            target: 'end',
            sourceHandle: getSourceHandle(nodeId),
            targetHandle: getTargetHandle('end')
          });
        });
      }
    }

    setNodes(newNodes);
    setEdges(newEdges);
  };

  const loadStrategyFlow = async () => {
    setLoading(true);
    try {
      console.log('🔗 === LOADING STRATEGY FLOW ===');
      console.log('🔗 Strategy ID:', strategyId);
      
      const [
        apiCallsResult, 
        modelCallsResult, 
        conditionNodesResult,
        strategyTriggerNodesResult,
        telegramMessageNodesResult
      ] = await Promise.all([
        api.getApiCalls(strategyId),
        api.getModelCalls(strategyId),
        api.getConditionNodes(strategyId),
        api.getStrategyTriggerNodes(strategyId),
        api.getTelegramMessageNodes(strategyId)
      ]);
      
      console.log('🔗 Raw API responses:');
      console.log('🔗 API calls result:', apiCallsResult);
      console.log('🔗 Model calls result:', modelCallsResult);
      console.log('🔗 Condition nodes result:', conditionNodesResult);
      console.log('🔗 Strategy trigger nodes result:', strategyTriggerNodesResult);
      console.log('🔗 Telegram message nodes result:', telegramMessageNodesResult);
      
      if (apiCallsResult.success) {
        console.log('🔗 Setting API calls:', apiCallsResult.data);
        setApiCalls(apiCallsResult.data || []);
      } else {
        console.error('🔗 Failed to load API calls:', apiCallsResult.error);
      }
      
      if (modelCallsResult.success) {
        console.log('🔗 Setting model calls:', modelCallsResult.data);
        setModelCalls(modelCallsResult.data || []);
      } else {
        console.error('🔗 Failed to load model calls:', modelCallsResult.error);
      }

      if (conditionNodesResult.success) {
        console.log('🔗 Setting condition nodes:', conditionNodesResult.data);
        setConditionNodes(conditionNodesResult.data || []);
      } else {
        console.error('🔗 Failed to load condition nodes:', conditionNodesResult.error);
      }

      if (strategyTriggerNodesResult.success) {
        console.log('🔗 Setting strategy trigger nodes:', strategyTriggerNodesResult.data);
        setStrategyTriggerNodes(strategyTriggerNodesResult.data || []);
      } else {
        console.error('🔗 Failed to load strategy trigger nodes:', strategyTriggerNodesResult.error);
      }

      if (telegramMessageNodesResult.success) {
        console.log('🔗 Setting telegram message nodes:', telegramMessageNodesResult.data);
        setTelegramMessageNodes(telegramMessageNodesResult.data || []);
      } else {
        console.error('🔗 Failed to load telegram message nodes:', telegramMessageNodesResult.error);
      }
      
      console.log('🔗 === LOADING COMPLETE ===');
    } catch (error) {
      console.error('🔗 Exception while loading strategy flow:', error);
    }
    setLoading(false);
  };

  const loadStrategy = async () => {
    try {
      const result = await api.getStrategies();
      if (result.success && result.data) {
        const currentStrategy = result.data.find(s => s.id === strategyId);
        if (currentStrategy) {
          setStrategy(currentStrategy);
        }
      }
    } catch (error) {
      console.error('Error loading strategy:', error);
    }
  };

  // Helper function to open API call editor and clear test results
  const openApiCallEditor = (apiCall: ApiCall) => {
    setTestResult(null); // Clear previous test results
    setTesting(false);   // Reset testing state
    setEditingApiCall(apiCall);
  };

  const handleSaveApiCall = async (apiCall: ApiCall) => {
    try {
      console.log('🔧 Attempting to save API call:', apiCall);
      
      let result;
      if (apiCall.id) {
        console.log('🔧 Updating existing API call with ID:', apiCall.id);
        result = await api.updateApiCall(strategyId, apiCall.id, apiCall);
      } else {
        console.log('🔧 Creating new API call for strategy:', strategyId);
        result = await api.createApiCall(strategyId, apiCall);
      }
      
      console.log('🔧 API call save result:', result);
      
      if (result.success) {
        console.log('✅ API call saved successfully');
        await loadStrategyFlow();
        setEditingApiCall(null);
        setTestResult(null); // Clear test results when closing
        setTesting(false);   // Reset testing state
      } else {
        console.error('❌ Failed to save API call:', result.error);
        alert(`Failed to save API call: ${result.error}`);
      }
    } catch (error) {
      console.error('❌ Exception while saving API call:', error);
      alert(`Error saving API call: ${error}`);
    }
  };

  const handleSaveModelCall = async (modelCall: ModelCall) => {
    try {
      console.log('🔧 Attempting to save model call:', modelCall);
      
      let result;
      if (modelCall.id) {
        console.log('🔧 Updating existing model call with ID:', modelCall.id);
        result = await api.updateModelCall(strategyId, modelCall.id, modelCall);
      } else {
        console.log('🔧 Creating new model call for strategy:', strategyId);
        result = await api.createModelCall(strategyId, modelCall);
      }
      
      console.log('🔧 Model call save result:', result);
      
      if (result.success) {
        console.log('✅ Model call saved successfully');
        await loadStrategyFlow();
        setEditingModelCall(null);
      } else {
        console.error('❌ Failed to save model call:', result.error);
        alert(`Failed to save model call: ${result.error}`);
      }
    } catch (error) {
      console.error('❌ Exception while saving model call:', error);
      alert(`Error saving model call: ${error}`);
    }
  };

  const handleDeleteApiCall = async (id: number) => {
    const result = await api.deleteApiCall(strategyId, id);
    if (result.success) {
      await loadStrategyFlow();
    }
  };

  const handleDeleteModelCall = async (id: number) => {
    const result = await api.deleteModelCall(strategyId, id);
    if (result.success) {
      await loadStrategyFlow();
    }
  };

  const handleTestApiCall = async (apiCall: ApiCall) => {
    setTesting(true);
    setTestResult(null);
    
    try {
      console.log('🧪 Testing API call:', apiCall);
      const result = await api.testApiCall(apiCall);
      console.log('🧪 Test result:', result);
      setTestResult(result);
      
      // Auto-scroll to test result
      setTimeout(() => {
        const testResultElement = document.querySelector('[data-test-result]');
        if (testResultElement) {
          testResultElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
      }, 100);
    } catch (error) {
      console.error('🧪 Test error:', error);
      setTestResult({ 
        success: false, 
        error: error instanceof Error ? error.message : 'Test failed - please check console for details' 
      });
    }
    
    setTesting(false);
  };

  const handleExecuteStrategy = async () => {
    setExecuting(true);
    setExecutionLogs([]);
    
    try {
      const result = await api.runStrategy(strategyId);
      console.log('Strategy execution result:', result);
      // For now, just log the result - we'll improve logging later
    } catch (error) {
      console.error('Strategy execution failed:', error);
    }
    
    setExecuting(false);
  };

  const getNextOrderIndex = () => {
    const allSteps = [...apiCalls, ...modelCalls, ...conditionNodes, ...strategyTriggerNodes, ...telegramMessageNodes];
    return allSteps.length > 0 ? Math.max(...allSteps.map(s => s.orderIndex)) + 1 : 1;
  };

  const renderFlowView = () => {
    return (
      <div className="space-y-4">
        <div className="flex justify-between items-center">
          <div className="flex flex-wrap gap-2">
            <Button 
              onClick={() => openApiCallEditor({
                name: '',
                url: '',
                method: 'GET',
                outputVariable: '',
                orderIndex: getNextOrderIndex(),
                enabled: true
              })} 
              className="flex items-center space-x-2 bg-gray-600 hover:bg-gray-700"
            >
              <GlobeIcon className="w-4 h-4" />
              <span>API Call</span>
            </Button>
            <Button 
              onClick={() => setEditingModelCall({
                name: '',
                modelTier: 'cheap',
                userPrompt: '',
                includeApiData: true,
                outputVariable: '',
                orderIndex: getNextOrderIndex(),
                enabled: true
              })} 
              className="flex items-center space-x-2 bg-gray-600 hover:bg-gray-700"
            >
              <BrainIcon className="w-4 h-4" />
              <span>Model Call</span>
            </Button>
            <Button 
              onClick={() => setEditingConditionNode({
                name: '',
                conditionType: 'api_result',
                leftOperand: '',
                operator: '==',
                rightOperand: '',
                orderIndex: getNextOrderIndex(),
                enabled: true
              })} 
              className="flex items-center space-x-2 bg-gray-600 hover:bg-gray-700"
            >
              <InformationCircleIcon className="w-4 h-4" />
              <span>Condition</span>
            </Button>
            <Button 
              onClick={() => setEditingStrategyTriggerNode({
                name: '',
                targetStrategyId: 0,
                waitForCompletion: false,
                orderIndex: getNextOrderIndex(),
                enabled: true
              })} 
              className="flex items-center space-x-2 bg-gray-600 hover:bg-gray-700"
            >
              <ArrowPathIcon className="w-4 h-4" />
              <span>Trigger Strategy</span>
            </Button>
            <Button 
              onClick={() => setEditingTelegramMessageNode({
                name: '',
                chatId: '',
                messageTemplate: '',
                includeApiData: false,
                messageType: 'info',
                parseMode: 'Markdown',
                orderIndex: getNextOrderIndex(),
                enabled: true
              })} 
              className="flex items-center space-x-2 bg-gray-600 hover:bg-gray-700"
            >
              <ChatBubbleLeftIcon className="w-4 h-4" />
              <span>Send to Telegram</span>
            </Button>
            <Button 
              onClick={() => {
                const endNode: Node = {
                  id: 'end',
                  type: 'end',
                  position: { x: 800, y: 200 },
                  data: {
                    name: 'End',
                    description: 'Flow ends here'
                  }
                };
                setNodes(prev => [...prev, endNode]);
              }} 
              className="flex items-center space-x-2 bg-gray-600 hover:bg-gray-700"
            >
              <XMarkIcon className="w-4 h-4" />
              <span>End Node</span>
            </Button>
            <Button 
              onClick={handleExecuteStrategy} 
              disabled={executing} 
              className="flex items-center space-x-2 bg-green-600 hover:bg-green-700"
            >
              <PlayIcon className="w-4 h-4" />
              <span>{executing ? 'Executing...' : 'Run Strategy'}</span>
            </Button>
          </div>
        </div>

        <div className="h-[500px] bg-gray-900 rounded-lg border border-gray-700 relative overflow-hidden">
          <ReactFlow
            nodes={nodes}
            edges={edges}
            onNodesChange={onNodesChange}
            onEdgesChange={onEdgesChange}
            onConnect={onConnect}
            nodeTypes={nodeTypes}
            defaultEdgeOptions={edgeOptions}
            fitView
            fitViewOptions={{ 
              padding: 0.1, 
              minZoom: 0.3, 
              maxZoom: 1.5,
              includeHiddenNodes: false
            }}
            defaultViewport={{ x: 0, y: 0, zoom: 0.7 }}
            className="bg-gray-900"
            connectionLineStyle={{ stroke: '#ffffff', strokeWidth: 2 }}
            connectionLineType={ConnectionLineType.SmoothStep}
            proOptions={{ hideAttribution: true }}
            elementsSelectable={true}
            nodesConnectable={true}
            nodesDraggable={true}
            zoomOnScroll={true}
            panOnScroll={false}
            selectNodesOnDrag={false}
            snapToGrid={true}
            snapGrid={[20, 20]}
            onInit={(reactFlowInstance) => {
              // Fit view with slight delay to ensure all nodes are rendered
              setTimeout(() => {
                reactFlowInstance.fitView({ 
                  padding: 0.15, 
                  minZoom: 0.3, 
                  maxZoom: 1.2,
                  duration: 800 
                });
              }, 300);
            }}
          >
            <Controls className="bg-gray-800 border border-gray-600 text-white" />
            <Background color="#374151" gap={16} variant={BackgroundVariant.Dots} />
          </ReactFlow>
        </div>

        {nodes.length === 0 && (
          <Card>
            <CardContent className="p-8 text-center">
              <h3 className="text-xl font-semibold text-white mb-2">No Flow Steps Configured</h3>
              <p className="text-gray-400 mb-4">
                Add API calls and model calls to build your strategy flow
              </p>
              <div className="flex justify-center space-x-4">
                <Button onClick={() => openApiCallEditor({
                  name: '',
                  url: '',
                  method: 'GET',
                  outputVariable: '',
                  orderIndex: getNextOrderIndex(),
                  enabled: true
                })}>
                  <GlobeIcon className="w-4 h-4 mr-2" />
                  Add API Call
                </Button>
                <Button onClick={() => setEditingModelCall({
                  name: '',
                  modelTier: 'cheap',
                  userPrompt: '',
                  includeApiData: true,
                  outputVariable: '',
                  orderIndex: getNextOrderIndex(),
                  enabled: true
                })}>
                  <BrainIcon className="w-4 h-4 mr-2" />
                  Add Model Call
                </Button>
              </div>
            </CardContent>
          </Card>
        )}

        {executionLogs.length > 0 && (
          <Card>
            <CardHeader>
              <CardTitle className="text-white">Execution Logs</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="space-y-2">
                {executionLogs.map((log, index) => (
                  <div key={index} className="flex items-start space-x-3 p-3 bg-gray-800 rounded">
                    <div className="flex-shrink-0">
                      {log.error ? (
                        <XMarkIcon className="w-4 h-4 text-red-400" />
                      ) : (
                        <CheckIcon className="w-4 h-4 text-green-400" />
                      )}
                    </div>
                    <div className="flex-1">
                      <p className="text-sm font-medium text-white">{log.stepName}</p>
                      <p className="text-xs text-gray-400">{log.duration}ms</p>
                      {log.error && (
                        <p className="text-xs text-red-400 mt-1">{log.error}</p>
                      )}
                    </div>
                  </div>
                ))}
              </div>
            </CardContent>
          </Card>
        )}
      </div>
    );
  };

  const renderApiCallsTab = () => (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <h3 className="text-lg font-semibold text-white">API Calls</h3>
        <Button onClick={() => openApiCallEditor({
          name: '',
          url: '',
          method: 'GET',
          outputVariable: '',
          orderIndex: getNextOrderIndex(),
          enabled: true
        })} className="flex items-center space-x-2">
          <PlusIcon className="w-4 h-4" />
          <span>Add API Call</span>
        </Button>
      </div>

      <div className="grid gap-4">
        {apiCalls.map((apiCall) => (
          <Card key={apiCall.id}>
            <CardContent className="p-4">
              <div className="flex justify-between items-start">
                <div>
                  <h4 className="font-medium text-white">{apiCall.name}</h4>
                  <p className="text-sm text-gray-400">{apiCall.method} {apiCall.url}</p>
                  <p className="text-xs text-green-400">Output: {apiCall.outputVariable}</p>
                  {apiCall.jsonPath && (
                    <p className="text-xs text-blue-400">JSON Path: {apiCall.jsonPath}</p>
                  )}
                  {!apiCall.jsonPath && (
                    <p className="text-xs text-yellow-400">Full response will be stored</p>
                  )}
                </div>
                <div className="flex items-center space-x-2">
                  <Button 
                    size="sm" 
                    variant="outline" 
                    onClick={() => handleTestApiCall(apiCall)}
                    disabled={testing}
                    className={testing ? 'opacity-50 cursor-not-allowed' : ''}
                  >
                    {testing ? (
                      <div className="w-4 h-4 animate-spin rounded-full border-2 border-gray-300 border-t-blue-600"></div>
                    ) : (
                      <TestTubeIcon className="w-4 h-4" />
                    )}
                    {testing ? 'Testing...' : 'Test'}
                  </Button>
                  <Button size="sm" variant="outline" onClick={() => openApiCallEditor(apiCall)}>
                    <EditIcon className="w-4 h-4" />
                  </Button>
                  <Button size="sm" variant="error" onClick={() => handleDeleteApiCall(apiCall.id!)}>
                    <TrashIcon className="w-4 h-4" />
                  </Button>
                </div>
              </div>
            </CardContent>
          </Card>
        ))}
      </div>

      {testResult && (
        <Card data-test-result>
          <CardHeader>
            <CardTitle className="text-white flex items-center space-x-2">
              {testResult.success ? (
                <CheckIcon className="w-5 h-5 text-green-400" />
              ) : (
                <XMarkIcon className="w-5 h-5 text-red-400" />
              )}
              <span>Test Result {testResult.success ? '✅' : '❌'}</span>
            </CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            {testResult.success ? (
              <>
                {testResult.data?.extractedValue !== undefined && (
                  <div>
                    <h4 className="text-sm font-medium text-green-400 mb-2">
                      ✨ Extracted Value (JSON Path: {testResult.jsonPath || 'N/A'})
                    </h4>
                    <div className="bg-green-900/20 border border-green-700 rounded p-3">
                      <code className="text-green-300 text-sm">
                        {Array.isArray(testResult.data.extractedValue) 
                          ? JSON.stringify(testResult.data.extractedValue[0], null, 2)
                          : JSON.stringify(testResult.data.extractedValue, null, 2)
                        }
                      </code>
                    </div>
                    <p className="text-xs text-green-400 mt-2">
                      This value will be stored in the "{testResult.outputVariable || 'output'}" variable
                    </p>
                  </div>
                )}
                
                <div>
                  <h4 className="text-sm font-medium text-blue-400 mb-2">📄 Full API Response</h4>
                  <pre className="text-xs bg-gray-800 p-3 rounded text-gray-300 overflow-auto max-h-40 border border-gray-600">
                    {JSON.stringify(testResult.data?.data || testResult.data, null, 2)}
                  </pre>
                </div>
                
                <div className="bg-green-900/10 border border-green-700 rounded p-3">
                  <p className="text-sm text-green-300">
                    🎉 API call successful! The extracted value will be available as a variable in your flow.
                  </p>
                </div>
              </>
            ) : (
              <div>
                <h4 className="text-sm font-medium text-red-400 mb-2">❌ Error Details</h4>
                <div className="bg-red-900/20 border border-red-700 rounded p-3">
                  <code className="text-red-300 text-sm">
                    {testResult.error || 'Unknown error occurred'}
                  </code>
                </div>
                <div className="bg-yellow-900/10 border border-yellow-700 rounded p-3 mt-3">
                  <p className="text-sm text-yellow-300">
                    💡 Troubleshooting tips:
                  </p>
                  <ul className="text-xs text-yellow-200 mt-2 space-y-1 list-disc list-inside">
                    <li>Check if the URL is accessible and returns valid JSON</li>
                    <li>Verify that any required headers are properly formatted</li>
                    <li>Test the JSON Path syntax if you're extracting specific values</li>
                    <li>Check the browser's network tab for more details</li>
                  </ul>
                </div>
              </div>
            )}
          </CardContent>
        </Card>
      )}
    </div>
  );

  const renderModelCallsTab = () => (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <h3 className="text-lg font-semibold text-white">Model Calls</h3>
        <Button onClick={() => setEditingModelCall({
          name: '',
          modelTier: 'cheap',
          userPrompt: '',
          includeApiData: true,
          outputVariable: '',
          orderIndex: getNextOrderIndex(),
          enabled: true
        })} className="flex items-center space-x-2">
          <PlusIcon className="w-4 h-4" />
          <span>Add Model Call</span>
        </Button>
      </div>

      <div className="grid gap-4">
        {modelCalls.map((modelCall) => (
          <Card key={modelCall.id}>
            <CardContent className="p-4">
              <div className="flex justify-between items-start">
                <div>
                  <h4 className="font-medium text-white">{modelCall.name}</h4>
                  <p className="text-sm text-gray-400">{modelCall.modelTier} model</p>
                  <p className="text-xs text-green-400">Output: {modelCall.outputVariable}</p>
                  <p className="text-xs text-purple-400">
                    {modelCall.includeApiData ? 'Includes API data' : 'No API data'}
                  </p>
                </div>
                <div className="flex items-center space-x-2">
                  <Button size="sm" variant="outline" onClick={() => setEditingModelCall(modelCall)}>
                    <EditIcon className="w-4 h-4" />
                  </Button>
                  <Button size="sm" variant="error" onClick={() => handleDeleteModelCall(modelCall.id!)}>
                    <TrashIcon className="w-4 h-4" />
                  </Button>
                </div>
              </div>
            </CardContent>
          </Card>
        ))}
      </div>
    </div>
  );

  const renderConditionNodesTab = () => (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <h3 className="text-lg font-semibold text-white">Condition Nodes</h3>
        <Button onClick={() => setEditingConditionNode({
          name: '',
          conditionType: 'api_result',
          leftOperand: '',
          operator: '==',
          rightOperand: '',
          orderIndex: getNextOrderIndex(),
          enabled: true
        })} className="flex items-center space-x-2">
          <PlusIcon className="w-4 h-4" />
          <span>Add Condition</span>
        </Button>
      </div>

      <div className="grid gap-4">
        {conditionNodes.map((conditionNode) => (
          <Card key={conditionNode.id}>
            <CardContent className="p-4">
              <div className="flex justify-between items-start">
                <div>
                  <h4 className="font-medium text-white">{conditionNode.name}</h4>
                  <p className="text-sm text-gray-400">{conditionNode.conditionType}</p>
                  <p className="text-xs text-yellow-400">
                    {conditionNode.leftOperand} {conditionNode.operator} {conditionNode.rightOperand}
                  </p>
                  <p className="text-xs text-green-400">
                    True → {conditionNode.trueOutputVariable || 'true'} | False → {conditionNode.falseOutputVariable || 'false'}
                  </p>
                </div>
                <div className="flex items-center space-x-2">
                  <Button size="sm" variant="outline" onClick={() => setEditingConditionNode(conditionNode)}>
                    <EditIcon className="w-4 h-4" />
                  </Button>
                  <Button size="sm" variant="error" onClick={() => handleDeleteConditionNode(conditionNode.id!)}>
                    <TrashIcon className="w-4 h-4" />
                  </Button>
                </div>
              </div>
            </CardContent>
          </Card>
        ))}
      </div>
    </div>
  );

  const renderStrategyTriggerNodesTab = () => (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <h3 className="text-lg font-semibold text-white">Strategy Trigger Nodes</h3>
        <Button onClick={() => setEditingStrategyTriggerNode({
          name: '',
          targetStrategyId: 0,
          waitForCompletion: false,
          orderIndex: getNextOrderIndex(),
          enabled: true
        })} className="flex items-center space-x-2">
          <PlusIcon className="w-4 h-4" />
          <span>Add Trigger</span>
        </Button>
      </div>

      <div className="grid gap-4">
        {strategyTriggerNodes.map((triggerNode) => (
          <Card key={triggerNode.id}>
            <CardContent className="p-4">
              <div className="flex justify-between items-start">
                <div>
                  <h4 className="font-medium text-white">{triggerNode.name}</h4>
                  <p className="text-sm text-gray-400">→ Strategy #{triggerNode.targetStrategyId}</p>
                  <p className="text-xs text-orange-400">
                    {triggerNode.waitForCompletion ? 'Wait for completion' : 'Fire & forget'}
                  </p>
                  {triggerNode.conditionVariable && (
                    <p className="text-xs text-orange-400">If: {triggerNode.conditionVariable}</p>
                  )}
                </div>
                <div className="flex items-center space-x-2">
                  <Button size="sm" variant="outline" onClick={() => setEditingStrategyTriggerNode(triggerNode)}>
                    <EditIcon className="w-4 h-4" />
                  </Button>
                  <Button size="sm" variant="error" onClick={() => {
                    // We need to add a delete handler here
                    if (window.confirm('Are you sure you want to delete this strategy trigger?')) {
                      // The delete handler will be passed down
                      if (triggerNode.id) {
                        handleDeleteStrategyTriggerNode(triggerNode.id!);
                      }
                    }
                  }}>
                    <TrashIcon className="w-4 h-4" />
                  </Button>
                </div>
              </div>
            </CardContent>
          </Card>
        ))}
      </div>
    </div>
  );

  const renderTelegramMessageNodesTab = () => (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <h3 className="text-lg font-semibold text-white">Telegram Message Nodes</h3>
        <Button onClick={() => setEditingTelegramMessageNode({
          name: '',
          chatId: '',
          messageTemplate: '',
          includeApiData: false,
          messageType: 'info',
          parseMode: 'Markdown',
          orderIndex: getNextOrderIndex(),
          enabled: true
        })} className="flex items-center space-x-2">
          <PlusIcon className="w-4 h-4" />
          <span>Add Telegram Message</span>
        </Button>
      </div>

      <div className="grid gap-4">
        {telegramMessageNodes.map((telegramNode) => (
          <Card key={telegramNode.id}>
            <CardContent className="p-4">
              <div className="flex justify-between items-start">
                <div>
                  <h4 className="font-medium text-white">{telegramNode.name}</h4>
                  <p className="text-sm text-gray-400">#{telegramNode.chatId}</p>
                  <p className="text-xs text-green-400">{telegramNode.messageType} message</p>
                  <p className="text-xs text-green-400">
                    {telegramNode.onlyIfVariable ? `Only if: ${telegramNode.onlyIfVariable}` : 'Always send'}
                  </p>
                </div>
                <div className="flex items-center space-x-2">
                  <Button size="sm" variant="outline" onClick={() => setEditingTelegramMessageNode(telegramNode)}>
                    <EditIcon className="w-4 h-4" />
                  </Button>
                  <Button size="sm" variant="error" onClick={() => handleDeleteTelegramMessageNode(telegramNode.id!)}>
                    <TrashIcon className="w-4 h-4" />
                  </Button>
                </div>
              </div>
            </CardContent>
          </Card>
        ))}
      </div>
    </div>
  );

  const handleSaveConditionNode = async (conditionNode: ConditionNode) => {
    try {
      let result;
      if (conditionNode.id) {
        result = await api.updateConditionNode(strategyId, conditionNode.id, conditionNode);
      } else {
        result = await api.createConditionNode(strategyId, conditionNode);
      }
      
      if (result.success) {
        await loadStrategyFlow();
        setEditingConditionNode(null);
      } else {
        alert(`Failed to save condition node: ${result.error}`);
      }
    } catch (error) {
      alert(`Error saving condition node: ${error}`);
    }
  };

  const handleDeleteConditionNode = async (id: number) => {
    const result = await api.deleteConditionNode(strategyId, id);
    if (result.success) {
      await loadStrategyFlow();
    }
  };

  const handleSaveStrategyTriggerNode = async (triggerNode: StrategyTriggerNode) => {
    try {
      let result;
      if (triggerNode.id) {
        result = await api.updateStrategyTriggerNode(strategyId, triggerNode.id, triggerNode);
      } else {
        result = await api.createStrategyTriggerNode(strategyId, triggerNode);
      }
      
      if (result.success) {
        await loadStrategyFlow();
        setEditingStrategyTriggerNode(null);
      } else {
        alert(`Failed to save strategy trigger node: ${result.error}`);
      }
    } catch (error) {
      alert(`Error saving strategy trigger node: ${error}`);
    }
  };

  const handleDeleteStrategyTriggerNode = async (id: number) => {
    const result = await api.deleteStrategyTriggerNode(strategyId, id);
    if (result.success) {
      await loadStrategyFlow();
    }
  };

  const handleSaveTelegramMessageNode = async (telegramNode: TelegramMessageNode) => {
    try {
      let result;
      if (telegramNode.id) {
        result = await api.updateTelegramMessageNode(strategyId, telegramNode.id, telegramNode);
      } else {
        result = await api.createTelegramMessageNode(strategyId, telegramNode);
      }
      
      if (result.success) {
        await loadStrategyFlow();
        setEditingTelegramMessageNode(null);
      } else {
        alert(`Failed to save telegram message node: ${result.error}`);
      }
    } catch (error) {
      alert(`Error saving telegram message node: ${error}`);
    }
  };

  const handleDeleteTelegramMessageNode = async (id: number) => {
    const result = await api.deleteTelegramMessageNode(strategyId, id);
    if (result.success) {
      await loadStrategyFlow();
    }
  };

  const handleSaveStrategy = async (strategyData: any) => {
    try {
      const result = await api.updateStrategy(strategyId, strategyData);
      if (result.success) {
        await loadStrategy();
        // Refresh parent component's strategy data
        if (onRefetch) {
          await onRefetch();
        }
        setEditingStrategy(null);
        // Success feedback will be visible through the updated UI
      } else {
        alert(`Failed to update strategy: ${result.error}`);
      }
    } catch (error) {
      alert(`Error updating strategy: ${error}`);
    }
  };

  if (loading) {
    return (
      <div className="fixed inset-0 z-50 bg-black/60 backdrop-blur-sm flex items-center justify-center">
        <div className="text-blue-400">Loading strategy flow...</div>
      </div>
    );
  }

  return (
    <div className="fixed inset-0 z-50 bg-black/60 backdrop-blur-sm">
      <div className="h-full overflow-y-auto">
        <div className="min-h-full flex items-center justify-center p-4">
          <Card className="w-full max-w-6xl max-h-[85vh] overflow-hidden">
            <CardHeader className="border-b pb-3">
              <div className="flex justify-between items-center">
                <CardTitle className="text-xl text-white">Strategy Flow Editor</CardTitle>
                <Button variant="outline" onClick={onClose}>
                  <XMarkIcon className="w-4 h-4" />
                </Button>
              </div>
              
              <div className="flex space-x-1 mt-3">
                <Button
                  variant={selectedTab === 'flow' ? 'default' : 'outline'}
                  size="sm"
                  onClick={() => setSelectedTab('flow')}
                >
                  Flow View
                </Button>
                <Button
                  variant={selectedTab === 'api' ? 'default' : 'outline'}
                  size="sm"
                  onClick={() => setSelectedTab('api')}
                >
                  API Calls ({apiCalls.length})
                </Button>
                <Button
                  variant={selectedTab === 'model' ? 'default' : 'outline'}
                  size="sm"
                  onClick={() => setSelectedTab('model')}
                >
                  Model Calls ({modelCalls.length})
                </Button>
                <Button
                  variant={selectedTab === 'condition' ? 'default' : 'outline'}
                  size="sm"
                  onClick={() => setSelectedTab('condition')}
                >
                  Conditions ({conditionNodes.length})
                </Button>
                <Button
                  variant={selectedTab === 'trigger' ? 'default' : 'outline'}
                  size="sm"
                  onClick={() => setSelectedTab('trigger')}
                >
                  Triggers ({strategyTriggerNodes.length})
                </Button>
                <Button
                  variant={selectedTab === 'telegram' ? 'default' : 'outline'}
                  size="sm"
                  onClick={() => setSelectedTab('telegram')}
                >
                  Telegram ({telegramMessageNodes.length})
                </Button>
                <Button
                  variant={selectedTab === 'settings' ? 'default' : 'outline'}
                  size="sm"
                  onClick={() => setSelectedTab('settings')}
                >
                  Settings
                </Button>
              </div>
            </CardHeader>
            
            <CardContent className="max-h-[65vh] overflow-y-auto p-4">
              {selectedTab === 'flow' && renderFlowView()}
              {selectedTab === 'api' && renderApiCallsTab()}
              {selectedTab === 'model' && renderModelCallsTab()}
              {selectedTab === 'condition' && renderConditionNodesTab()}
              {selectedTab === 'trigger' && renderStrategyTriggerNodesTab()}
              {selectedTab === 'telegram' && renderTelegramMessageNodesTab()}
              {selectedTab === 'settings' && (
                <div className="space-y-6">
                  <div className="flex justify-between items-center">
                    <h3 className="text-lg font-semibold text-white">Strategy Settings</h3>
                    <Button onClick={() => setEditingStrategy(strategy)} className="flex items-center space-x-2">
                      <EditIcon className="w-4 h-4" />
                      <span>Edit Strategy</span>
                    </Button>
                  </div>
                  
                  {strategy ? (
                    <div className="grid gap-6">
                      <Card className="bg-gray-800 border-gray-700">
                        <CardContent className="p-6">
                          <div className="grid gap-4">
                            <div>
                              <Label className="text-white">Name</Label>
                              <div className="text-gray-300 font-medium">{strategy.name}</div>
                            </div>
                            <div>
                              <Label className="text-white">Description</Label>
                              <div className="text-gray-300">{strategy.description || 'No description provided'}</div>
                            </div>
                            <div className="flex items-center space-x-2 mb-4">
                              <input
                                type="checkbox"
                                id="manualOnly"
                                checked={strategy.cron === null || strategy.cron === ''}
                                onChange={(e) => setEditingStrategy({...strategy, cron: e.target.checked ? null : '*/5 * * * *'})}
                                className="rounded"
                              />
                              <Label htmlFor="manualOnly">Manual execution only (no automatic schedule)</Label>
                            </div>
                            {strategy.cron && (
                              <div>
                                <Label htmlFor="cron">Cron Expression</Label>
                                <Input
                                  id="cron"
                                  value={strategy.cron || ''}
                                  onChange={(e) => setEditingStrategy({...strategy, cron: e.target.value})}
                                  placeholder="0 9 * * *"
                                />
                                <p className="text-xs text-gray-400 mt-1">
                                  Format: minute hour day month weekday (e.g., "0 9 * * *" = 9 AM daily)
                                </p>
                              </div>
                            )}
                          </div>
                        </CardContent>
                      </Card>
                    </div>
                  ) : (
                    <Card className="bg-gray-800 border-gray-700">
                      <CardContent className="p-8 text-center">
                        <div className="text-gray-400">Loading strategy settings...</div>
                      </CardContent>
                    </Card>
                  )}
                </div>
              )}
            </CardContent>
          </Card>
        </div>
      </div>

      {/* API Call Editor Modal */}
      {editingApiCall && (
        <div className="fixed inset-0 z-60 bg-black/80 backdrop-blur-sm flex items-center justify-center p-4">
          <Card className="w-full max-w-4xl max-h-[80vh] overflow-y-auto">
            <CardHeader>
              <CardTitle className="text-white">
                {editingApiCall.id ? 'Edit API Call' : 'Create API Call'}
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-3">
              <div className="grid grid-cols-2 gap-4">
                <div>
                  <Label htmlFor="name" className="text-white">Name</Label>
                  <Input
                    id="name"
                    value={editingApiCall.name}
                    onChange={(e) => setEditingApiCall({...editingApiCall, name: e.target.value})}
                    className="h-8"
                  />
                </div>
                <div>
                  <Label htmlFor="method" className="text-white">Method</Label>
                  <select
                    value={editingApiCall.method}
                    onChange={(e) => setEditingApiCall({...editingApiCall, method: e.target.value})}
                    className="h-8 w-full rounded-md border border-gray-600 bg-gray-800 px-3 text-sm text-white"
                  >
                    <option value="GET">GET</option>
                    <option value="POST">POST</option>
                    <option value="PUT">PUT</option>
                    <option value="DELETE">DELETE</option>
                  </select>
                </div>
              </div>
              
              <div>
                <Label htmlFor="url" className="text-white">URL</Label>
                <Input
                  id="url"
                  value={editingApiCall.url}
                  onChange={(e) => setEditingApiCall({...editingApiCall, url: e.target.value})}
                  className="h-8"
                />
              </div>

              <div className="grid grid-cols-2 gap-4">
                <div>
                  <Label htmlFor="outputVariable" className="text-white">Output Variable</Label>
                  <Input
                    id="outputVariable"
                    value={editingApiCall.outputVariable}
                    onChange={(e) => setEditingApiCall({...editingApiCall, outputVariable: e.target.value})}
                    className="h-8"
                  />
                </div>
                <div>
                  <Label htmlFor="orderIndex" className="text-white">Order</Label>
                  <Input
                    id="orderIndex"
                    type="number"
                    value={editingApiCall.orderIndex}
                    onChange={(e) => setEditingApiCall({...editingApiCall, orderIndex: parseInt(e.target.value)})}
                    className="h-8"
                  />
                </div>
              </div>

              <div className="flex items-center space-x-2">
                <input
                  type="checkbox"
                  checked={editingApiCall.enabled}
                  onChange={(e) => setEditingApiCall({...editingApiCall, enabled: e.target.checked})}
                  className="rounded"
                />
                <Label className="text-white">Enabled</Label>
              </div>

              {/* Test Section */}
              <div className="border-t border-gray-600 pt-4">
                <div className="flex items-center justify-between mb-3">
                  <Label className="text-white text-lg">Test API Call</Label>
                  <Button 
                    onClick={() => handleTestApiCall(editingApiCall)}
                    disabled={testing || !editingApiCall.url}
                    className="bg-blue-600 hover:bg-blue-700"
                  >
                    {testing ? (
                      <div className="w-4 h-4 animate-spin rounded-full border-2 border-gray-300 border-t-blue-600 mr-2"></div>
                    ) : (
                      <TestTubeIcon className="w-4 h-4 mr-2" />
                    )}
                    {testing ? 'Testing...' : 'Test Call'}
                  </Button>
                </div>

                {testResult && (
                  <div className="bg-gray-800 border border-gray-600 rounded-lg p-4 mb-4">
                    <div className="flex items-center space-x-2 mb-3">
                      {testResult.success ? (
                        <CheckIcon className="w-5 h-5 text-green-400" />
                      ) : (
                        <XMarkIcon className="w-5 h-5 text-red-400" />
                      )}
                      <span className="text-white font-medium">
                        Test Result {testResult.success ? '✅' : '❌'}
                      </span>
                    </div>

                    {testResult.success ? (
                      <div className="space-y-3">
                        {/* JSON Path Configuration */}
                        <div>
                          <Label htmlFor="jsonPath" className="text-white">JSON Path (optional)</Label>
                          <div className="flex space-x-2">
                            <Input
                              id="jsonPath"
                              value={editingApiCall.jsonPath || ''}
                              onChange={(e) => setEditingApiCall({...editingApiCall, jsonPath: e.target.value})}
                              placeholder="$.data.price"
                              className="h-8 flex-1"
                            />
                            <Button 
                              onClick={() => handleTestApiCall(editingApiCall)}
                              size="sm"
                              className="bg-gray-600 hover:bg-gray-700"
                            >
                              Preview
                            </Button>
                          </div>
                          <p className="text-xs text-gray-400 mt-1">
                            Leave empty to store the full response. Use JSON path to extract specific values.
                          </p>
                        </div>

                        {/* Extracted Value Preview */}
                        {testResult.data?.extractedValue !== undefined && (
                          <div>
                            <Label className="text-green-400 text-sm">
                              ✨ Extracted Value Preview
                            </Label>
                            <div className="bg-green-900/20 border border-green-700 rounded p-3 mt-1">
                              <code className="text-green-300 text-sm block whitespace-pre-wrap">
                                {Array.isArray(testResult.data.extractedValue) 
                                  ? JSON.stringify(testResult.data.extractedValue[0], null, 2)
                                  : JSON.stringify(testResult.data.extractedValue, null, 2)
                                }
                              </code>
                            </div>
                            <p className="text-xs text-green-400 mt-1">
                              This value will be stored in the "{editingApiCall.outputVariable || 'output'}" variable
                            </p>
                          </div>
                        )}

                        {/* Full Response (collapsed by default) */}
                        <details className="bg-gray-900 border border-gray-600 rounded">
                          <summary className="cursor-pointer p-2 text-blue-400 text-sm font-medium">
                            📄 Full API Response (click to expand)
                          </summary>
                          <div className="p-3 border-t border-gray-600">
                            <pre className="text-xs text-gray-300 overflow-auto max-h-32">
                              {JSON.stringify(testResult.data?.data || testResult.data, null, 2)}
                            </pre>
                          </div>
                        </details>
                      </div>
                    ) : (
                      <div className="bg-red-900/20 border border-red-700 rounded p-3">
                        <p className="text-red-300 text-sm font-medium mb-2">❌ Error Details</p>
                        <code className="text-red-300 text-sm block">
                          {testResult.error || 'Unknown error occurred'}
                        </code>
                        <div className="bg-yellow-900/10 border border-yellow-700 rounded p-2 mt-3">
                          <p className="text-yellow-300 text-xs">
                            💡 Check the URL, method, and ensure the API is accessible
                          </p>
                        </div>
                      </div>
                    )}
                  </div>
                )}
              </div>

              <div className="flex justify-between pt-4">
                <div>
                  {editingApiCall.id && (
                    <Button 
                      variant="outline" 
                      onClick={() => {
                        handleDeleteApiCall(editingApiCall.id!);
                        setEditingApiCall(null);
                        setTestResult(null); // Clear test results when closing
                        setTesting(false);   // Reset testing state
                      }}
                      className="bg-red-600 hover:bg-red-700 text-white"
                    >
                      <TrashIcon className="w-4 h-4 mr-2" />
                      Delete
                    </Button>
                  )}
                </div>
                <div className="flex space-x-2">
                  <Button variant="outline" onClick={() => {
                    setEditingApiCall(null);
                    setTestResult(null); // Clear test results when closing
                    setTesting(false);   // Reset testing state
                  }}>
                    Cancel
                  </Button>
                  <Button onClick={() => handleSaveApiCall(editingApiCall)}>
                    {editingApiCall.id ? 'Update' : 'Create'}
                  </Button>
                </div>
              </div>
            </CardContent>
          </Card>
        </div>
      )}

      {/* Model Call Editor Modal */}
      {editingModelCall && (
        <div className="fixed inset-0 z-60 bg-black/80 backdrop-blur-sm flex items-center justify-center p-4">
          <Card className="w-full max-w-2xl max-h-[80vh] overflow-y-auto">
            <CardHeader>
              <CardTitle className="text-white">
                {editingModelCall.id ? 'Edit Model Call' : 'Create Model Call'}
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-3">
              <div className="grid grid-cols-4 items-center gap-4">
                <Label htmlFor="name" className="text-right text-white">Name</Label>
                <Input
                  id="name"
                  value={editingModelCall.name}
                  onChange={(e) => setEditingModelCall({...editingModelCall, name: e.target.value})}
                  className="col-span-3 h-8"
                />
              </div>
              <div className="grid grid-cols-4 items-center gap-4">
                <Label htmlFor="modelTier" className="text-right text-white">Model Tier</Label>
                <select
                  value={editingModelCall.modelTier}
                  onChange={(e) => setEditingModelCall({...editingModelCall, modelTier: e.target.value as 'cheap' | 'deep'})}
                  className="col-span-3 h-8 rounded-md border border-gray-600 bg-gray-800 px-3 text-sm text-white"
                >
                  <option value="cheap">Cheap</option>
                  <option value="deep">Deep</option>
                </select>
              </div>
              <div className="grid grid-cols-4 items-center gap-4">
                <Label htmlFor="systemPrompt" className="text-right text-white">System Prompt</Label>
                <Textarea
                  id="systemPrompt"
                  value={editingModelCall.systemPrompt || ''}
                  onChange={(e) => setEditingModelCall({...editingModelCall, systemPrompt: e.target.value})}
                  className="col-span-3 h-16"
                />
              </div>
              <div className="grid grid-cols-4 items-center gap-4">
                <Label htmlFor="userPrompt" className="text-right text-white">User Prompt</Label>
                <Textarea
                  id="userPrompt"
                  value={editingModelCall.userPrompt}
                  onChange={(e) => setEditingModelCall({...editingModelCall, userPrompt: e.target.value})}
                  className="col-span-3 h-16"
                />
              </div>
              <div className="grid grid-cols-4 items-center gap-4">
                <Label htmlFor="outputVariable" className="text-right text-white">Output Variable</Label>
                <Input
                  id="outputVariable"
                  value={editingModelCall.outputVariable}
                  onChange={(e) => setEditingModelCall({...editingModelCall, outputVariable: e.target.value})}
                  className="col-span-3 h-8"
                />
              </div>
              <div className="grid grid-cols-4 items-center gap-4">
                <Label className="text-right text-white">Include API Data</Label>
                <div className="col-span-3">
                  <input
                    type="checkbox"
                    checked={editingModelCall.includeApiData}
                    onChange={(e) => setEditingModelCall({...editingModelCall, includeApiData: e.target.checked})}
                    className="rounded"
                  />
                </div>
              </div>
              <div className="flex justify-between pt-4">
                <div>
                  {editingModelCall.id && (
                    <Button 
                      variant="outline" 
                      onClick={() => {
                        handleDeleteModelCall(editingModelCall.id!);
                        setEditingModelCall(null);
                      }}
                      className="bg-red-600 hover:bg-red-700 text-white"
                    >
                      <TrashIcon className="w-4 h-4 mr-2" />
                      Delete
                    </Button>
                  )}
                </div>
                <div className="flex space-x-2">
                  <Button variant="outline" onClick={() => setEditingModelCall(null)}>
                    Cancel
                  </Button>
                  <Button onClick={() => handleSaveModelCall(editingModelCall)}>
                    {editingModelCall.id ? 'Update' : 'Create'}
                  </Button>
                </div>
              </div>
            </CardContent>
          </Card>
        </div>
      )}

      {/* Condition Node Editor Modal */}
      {editingConditionNode && (
        <ConditionNodeEditor
          conditionNode={editingConditionNode}
          onSave={handleSaveConditionNode}
          onCancel={() => setEditingConditionNode(null)}
          availableVariables={availableVariables}
          apiCalls={apiCalls}
          modelCalls={modelCalls}
        />
      )}

      {/* Strategy Trigger Node Editor Modal */}
      {editingStrategyTriggerNode && (
        <StrategyTriggerNodeEditor
          triggerNode={editingStrategyTriggerNode}
          onSave={handleSaveStrategyTriggerNode}
          onCancel={() => setEditingStrategyTriggerNode(null)}
          onDelete={editingStrategyTriggerNode.id ? () => {
            handleDeleteStrategyTriggerNode(editingStrategyTriggerNode.id!);
            setEditingStrategyTriggerNode(null);
          } : undefined}
          availableStrategies={availableStrategies}
          availableVariables={availableVariables}
        />
      )}

      {/* Telegram Message Node Editor Modal */}
      {editingTelegramMessageNode && (
        <TelegramMessageNodeEditor
          telegramNode={editingTelegramMessageNode}
          onSave={handleSaveTelegramMessageNode}
          onCancel={() => setEditingTelegramMessageNode(null)}
          onDelete={editingTelegramMessageNode.id ? () => {
            handleDeleteTelegramMessageNode(editingTelegramMessageNode.id!);
            setEditingTelegramMessageNode(null);
          } : undefined}
        />
      )}

      {/* Strategy Settings Editor Modal */}
      {editingStrategy && (
        <StrategySettingsEditor
          strategy={editingStrategy}
          onSave={handleSaveStrategy}
          onCancel={() => setEditingStrategy(null)}
        />
      )}
    </div>
  );
}

// Condition Node Editor Component
function ConditionNodeEditor({ 
  conditionNode, 
  onSave, 
  onCancel, 
  availableVariables, 
  apiCalls, 
  modelCalls 
}: { 
  conditionNode: ConditionNode; 
  onSave: (conditionNode: ConditionNode) => void; 
  onCancel: () => void;
  availableVariables: string[];
  apiCalls: ApiCall[];
  modelCalls: ModelCall[];
}) {
  const [formData, setFormData] = useState(conditionNode);

  // Filter available variables based on condition type
  const getFilteredVariables = () => {
    switch (formData.conditionType) {
      case 'api_result':
        return apiCalls
          .filter(call => call.outputVariable)
          .map(call => call.outputVariable);
      case 'model_response':
        return modelCalls
          .filter(call => call.outputVariable)
          .map(call => call.outputVariable);
      case 'variable_value':
      default:
        return availableVariables;
    }
  };

  const filteredVariables = getFilteredVariables();

  return (
    <div className="fixed inset-0 z-60 bg-black/80 backdrop-blur-sm flex items-center justify-center p-4">
      <Card className="w-full max-w-2xl">
        <CardHeader>
          <CardTitle className="text-white">
            {conditionNode.id ? 'Edit Condition Node' : 'New Condition Node'}
          </CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="grid grid-cols-2 gap-4">
            <div>
              <Label htmlFor="name">Name</Label>
              <Input
                id="name"
                value={formData.name}
                onChange={(e) => setFormData({...formData, name: e.target.value})}
                placeholder="Price Check"
              />
            </div>
            <div>
              <Label htmlFor="conditionType">Condition Type</Label>
              <select
                value={formData.conditionType}
                onChange={(e) => {
                  const newConditionType = e.target.value as any;
                  setFormData({
                    ...formData, 
                    conditionType: newConditionType,
                    leftOperand: '' // Reset left operand when type changes
                  });
                }}
                className="flex h-10 w-full rounded-md border border-gray-600 bg-gray-800 px-3 py-2 text-sm text-white focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent disabled:cursor-not-allowed disabled:opacity-50"
              >
                <option value="variable_value">Variable Value (Any)</option>
                <option value="api_result">API Result</option>
                <option value="model_response">Model Response</option>
              </select>
              <p className="text-xs text-gray-400 mt-1">
                {formData.conditionType === 'api_result' && 'Compare values from API calls'}
                {formData.conditionType === 'model_response' && 'Compare values from model responses'}
                {formData.conditionType === 'variable_value' && 'Compare any available variable'}
              </p>
            </div>
          </div>

          <div className="grid grid-cols-3 gap-4">
            <div>
              <Label htmlFor="leftOperand">
                Left Operand {formData.conditionType === 'api_result' ? '(API Variables)' : 
                            formData.conditionType === 'model_response' ? '(Model Variables)' : 
                            '(All Variables)'}
              </Label>
              <select
                value={formData.leftOperand}
                onChange={(e) => setFormData({...formData, leftOperand: e.target.value})}
                className="flex h-10 w-full rounded-md border border-gray-600 bg-gray-800 px-3 py-2 text-sm text-white focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent disabled:cursor-not-allowed disabled:opacity-50"
              >
                <option value="">
                  {formData.conditionType === 'api_result' ? 'Select API variable' :
                   formData.conditionType === 'model_response' ? 'Select model variable' :
                   'Select a variable'}
                </option>
                {filteredVariables.map(variable => {
                  // Find the source of this variable for better context
                  const apiSource = apiCalls.find(call => call.outputVariable === variable);
                  const modelSource = modelCalls.find(call => call.outputVariable === variable);
                  const label = apiSource ? `${variable} (${apiSource.name})` :
                               modelSource ? `${variable} (${modelSource.name})` :
                               variable;
                  return (
                    <option key={variable} value={variable}>{label}</option>
                  );
                })}
              </select>
              <div className="mt-2">
                <Input
                  placeholder="Or enter custom value"
                  value={formData.leftOperand}
                  onChange={(e) => setFormData({...formData, leftOperand: e.target.value})}
                />
              </div>
            </div>
            <div>
              <Label htmlFor="operator">Operator</Label>
              <select
                value={formData.operator}
                onChange={(e) => setFormData({...formData, operator: e.target.value as any})}
                className="flex h-10 w-full rounded-md border border-gray-600 bg-gray-800 px-3 py-2 text-sm text-white focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent disabled:cursor-not-allowed disabled:opacity-50"
              >
                <option value="==">=  (equals)</option>
                <option value="!=">!=  (not equals)</option>
                <option value=">">&gt;  (greater than)</option>
                <option value="<">&lt;  (less than)</option>
                <option value=">=">&gt;=  (greater or equal)</option>
                <option value="<=">&lt;=  (less or equal)</option>
                <option value="contains">contains (text)</option>
                <option value="startsWith">starts with (text)</option>
                <option value="endsWith">ends with (text)</option>
              </select>
            </div>
            <div>
              <Label htmlFor="rightOperand">Right Operand</Label>
              <Input
                id="rightOperand"
                value={formData.rightOperand}
                onChange={(e) => setFormData({...formData, rightOperand: e.target.value})}
                placeholder={
                  ['>', '<', '>=', '<='].includes(formData.operator) ? 'e.g., 50000' :
                  ['contains', 'startsWith', 'endsWith'].includes(formData.operator) ? 'e.g., "Bitcoin"' :
                  'Value to compare'
                }
              />
              <div className="mt-1">
                <select
                  value=""
                  onChange={(e) => e.target.value && setFormData({...formData, rightOperand: e.target.value})}
                  className="flex h-8 w-full rounded-md border border-gray-600 bg-gray-800 px-2 py-1 text-xs text-white focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent disabled:cursor-not-allowed disabled:opacity-50"
                >
                  <option value="">Or select variable</option>
                  {availableVariables.map(variable => (
                    <option key={variable} value={variable}>{variable}</option>
                  ))}
                </select>
              </div>
            </div>
          </div>

          <div className="grid grid-cols-2 gap-4">
            <div>
              <Label htmlFor="trueOutputVariable">True Output Variable (optional)</Label>
              <Input
                id="trueOutputVariable"
                value={formData.trueOutputVariable || ''}
                onChange={(e) => setFormData({...formData, trueOutputVariable: e.target.value || undefined})}
                placeholder="highPrice"
              />
              <p className="text-xs text-gray-400 mt-1">
                Variable created when condition is TRUE (connects to green handle)
              </p>
            </div>
            <div>
              <Label htmlFor="falseOutputVariable">False Output Variable (optional)</Label>
              <Input
                id="falseOutputVariable"
                value={formData.falseOutputVariable || ''}
                onChange={(e) => setFormData({...formData, falseOutputVariable: e.target.value || undefined})}
                placeholder="lowPrice"
              />
              <p className="text-xs text-gray-400 mt-1">
                Variable created when condition is FALSE (connects to red handle)
              </p>
            </div>
          </div>

          {/* Flow Connection Guide */}
          <div className="bg-blue-900/20 border border-blue-700 rounded-lg p-4">
            <Label className="text-blue-300">💡 Flow Connection Guide</Label>
            <div className="text-sm text-blue-200 mt-2 space-y-1">
              <div className="flex items-center space-x-2">
                <div className="w-3 h-3 bg-green-400 rounded-full"></div>
                <span>Connect GREEN handle to nodes that run when condition is TRUE</span>
              </div>
              <div className="flex items-center space-x-2">
                <div className="w-3 h-3 bg-red-400 rounded-full"></div>
                <span>Connect RED handle to nodes that run when condition is FALSE</span>
              </div>
              <div className="text-xs text-blue-300 mt-2">
                💡 Tip: Drag from the colored handles on the right side of the condition node to create different paths
              </div>
            </div>
          </div>

          {/* Condition Preview */}
          {formData.leftOperand && formData.operator && formData.rightOperand && (
            <div className="bg-gray-800 border border-gray-600 rounded-lg p-4">
              <Label className="text-white">Condition Preview</Label>
              <div className="text-sm text-gray-300 mt-2 font-mono">
                <span className="text-blue-300">{formData.leftOperand}</span>
                <span className="text-yellow-300 mx-2">{formData.operator}</span>
                <span className="text-green-300">{formData.rightOperand}</span>
              </div>
              <div className="text-xs text-gray-400 mt-2">
                <div className="flex items-center space-x-1">
                  <div className="w-2 h-2 bg-green-400 rounded-full"></div>
                  <span>If TRUE → Variable: <span className="text-green-400">{formData.trueOutputVariable || 'condition_result'}</span></span>
                </div>
                <div className="flex items-center space-x-1">
                  <div className="w-2 h-2 bg-red-400 rounded-full"></div>
                  <span>If FALSE → Variable: <span className="text-red-400">{formData.falseOutputVariable || 'condition_result'}</span></span>
                </div>
              </div>
            </div>
          )}

          <div className="flex justify-end space-x-2 pt-4">
            <Button variant="outline" onClick={onCancel}>Cancel</Button>
            <Button onClick={() => onSave(formData)}>Save</Button>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}

// Strategy Trigger Node Editor Component
function StrategyTriggerNodeEditor({ 
  triggerNode, 
  onSave, 
  onCancel, 
  onDelete, 
  availableStrategies, 
  availableVariables 
}: { 
  triggerNode: StrategyTriggerNode; 
  onSave: (triggerNode: StrategyTriggerNode) => void; 
  onCancel: () => void;
  onDelete?: () => void;
  availableStrategies: Strategy[];
  availableVariables: string[];
}) {
  const [formData, setFormData] = useState(triggerNode);

  return (
    <div className="fixed inset-0 z-60 bg-black/80 backdrop-blur-sm flex items-center justify-center p-4">
      <Card className="w-full max-w-2xl">
        <CardHeader>
          <CardTitle className="text-white">
            {triggerNode.id ? 'Edit Strategy Trigger' : 'New Strategy Trigger'}
          </CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="grid grid-cols-2 gap-4">
            <div>
              <Label htmlFor="name">Name</Label>
              <Input
                id="name"
                value={formData.name}
                onChange={(e) => setFormData({...formData, name: e.target.value})}
                placeholder="Trigger Alert Strategy"
              />
            </div>
            <div>
              <Label htmlFor="targetStrategyId">Target Strategy ID</Label>
              <select
                value={formData.targetStrategyId}
                onChange={(e) => setFormData({...formData, targetStrategyId: Number(e.target.value)})}
                className="flex h-10 w-full rounded-md border border-gray-600 bg-gray-800 px-3 py-2 text-sm text-white focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent disabled:cursor-not-allowed disabled:opacity-50"
              >
                <option value="">Select a strategy</option>
                {availableStrategies.map(strategy => (
                  <option key={strategy.id} value={strategy.id}>{strategy.name}</option>
                ))}
              </select>
            </div>
          </div>

          <div>
            <Label htmlFor="conditionVariable">Condition Variable (optional)</Label>
            <select
              value={formData.conditionVariable || ''}
              onChange={(e) => setFormData({...formData, conditionVariable: e.target.value || undefined})}
              className="flex h-10 w-full rounded-md border border-gray-600 bg-gray-800 px-3 py-2 text-sm text-white focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent disabled:cursor-not-allowed disabled:opacity-50"
            >
              <option value="">Select a variable</option>
              {availableVariables.map(variable => (
                <option key={variable} value={variable}>{variable}</option>
              ))}
            </select>
            <p className="text-xs text-gray-400 mt-1">
              Only trigger if this variable is truthy. Leave empty to always trigger.
            </p>
          </div>

          <div>
            <Label htmlFor="passVariables">Variables to Pass (comma-separated)</Label>
            <Input
              id="passVariables"
              value={formData.passVariables?.join(', ') || ''}
              onChange={(e) => setFormData({...formData, passVariables: e.target.value ? e.target.value.split(',').map(v => v.trim()) : []})}
              placeholder="btcPrice, analysis"
            />
          </div>

          <div className="grid grid-cols-2 gap-4">
            <div className="flex items-center space-x-2">
              <input
                type="checkbox"
                id="waitForCompletion"
                checked={formData.waitForCompletion}
                onChange={(e) => setFormData({...formData, waitForCompletion: e.target.checked})}
                className="rounded"
              />
              <Label htmlFor="waitForCompletion">Wait for completion</Label>
            </div>
            <div>
              <Label htmlFor="outputVariable">Output Variable (if waiting)</Label>
              <Input
                id="outputVariable"
                value={formData.outputVariable || ''}
                onChange={(e) => setFormData({...formData, outputVariable: e.target.value || undefined})}
                placeholder="triggerResult"
                disabled={!formData.waitForCompletion}
              />
            </div>
          </div>

          <div className="flex justify-between pt-4">
            <div>
              {triggerNode.id && (
                <Button 
                  variant="outline" 
                  onClick={() => {
                    // We need to add a delete handler here
                    if (window.confirm('Are you sure you want to delete this strategy trigger?')) {
                      // The delete handler will be passed down
                      if (onDelete) {
                        onDelete(); // Close modal first
                      }
                    }
                  }}
                  className="bg-red-600 hover:bg-red-700 text-white"
                >
                  <TrashIcon className="w-4 h-4 mr-2" />
                  Delete
                </Button>
              )}
            </div>
            <div className="flex space-x-2">
              <Button variant="outline" onClick={onCancel}>Cancel</Button>
              <Button onClick={() => onSave(formData)}>Save</Button>
            </div>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}

// Telegram Message Node Editor Component
function TelegramMessageNodeEditor({ 
  telegramNode, 
  onSave, 
  onCancel, 
  onDelete 
}: { 
  telegramNode: TelegramMessageNode; 
  onSave: (telegramNode: TelegramMessageNode) => void; 
  onCancel: () => void;
  onDelete?: () => void;
}) {
  const [formData, setFormData] = useState(telegramNode);

  return (
    <div className="fixed inset-0 z-60 bg-black/80 backdrop-blur-sm flex items-center justify-center p-4">
      <Card className="w-full max-w-3xl">
        <CardHeader>
          <CardTitle className="text-white">
            {telegramNode.id ? 'Edit Telegram Message' : 'New Telegram Message'}
          </CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="grid grid-cols-2 gap-4">
            <div>
              <Label htmlFor="name">Name</Label>
              <Input
                id="name"
                value={formData.name}
                onChange={(e) => setFormData({...formData, name: e.target.value})}
                placeholder="Price Alert"
              />
            </div>
            <div>
              <Label htmlFor="chatId">Telegram Chat ID</Label>
              <Input
                id="chatId"
                value={formData.chatId}
                onChange={(e) => setFormData({...formData, chatId: e.target.value})}
                placeholder="@mychannel or -1001234567890"
              />
              <p className="text-xs text-gray-400 mt-1">
                Use @channelname for public channels or chat ID for private groups
              </p>
            </div>
          </div>

          <div>
            <Label htmlFor="messageTemplate">Message Template</Label>
            <Textarea
              id="messageTemplate"
              value={formData.messageTemplate}
              onChange={(e) => setFormData({...formData, messageTemplate: e.target.value})}
              placeholder="🚨 BTC Price Alert: {{btcPrice}} USDT"
              rows={4}
            />
            <p className="text-xs text-gray-400 mt-1">
              Use {'{{'} variableName {'}'} to include variables in your message.
            </p>
          </div>

          <div className="grid grid-cols-3 gap-4">
            <div>
              <Label htmlFor="messageType">Message Type</Label>
              <select
                value={formData.messageType}
                onChange={(e) => setFormData({...formData, messageType: e.target.value as any})}
                className="flex h-10 w-full rounded-md border border-gray-600 bg-gray-800 px-3 py-2 text-sm text-white focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent disabled:cursor-not-allowed disabled:opacity-50"
              >
                <option value="info">Info</option>
                <option value="success">Success</option>
                <option value="warning">Warning</option>
                <option value="error">Error</option>
              </select>
            </div>
            <div>
              <Label htmlFor="parseMode">Parse Mode</Label>
              <select
                value={formData.parseMode || 'Markdown'}
                onChange={(e) => setFormData({...formData, parseMode: e.target.value as any})}
                className="flex h-10 w-full rounded-md border border-gray-600 bg-gray-800 px-3 py-2 text-sm text-white focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent disabled:cursor-not-allowed disabled:opacity-50"
              >
                <option value="Markdown">Markdown</option>
                <option value="HTML">HTML</option>
                <option value="none">Plain Text</option>
              </select>
            </div>
            <div>
              <Label htmlFor="onlyIfVariable">Only Send If Variable (optional)</Label>
              <Input
                id="onlyIfVariable"
                value={formData.onlyIfVariable || ''}
                onChange={(e) => setFormData({...formData, onlyIfVariable: e.target.value || undefined})}
                placeholder="highPrice"
              />
            </div>
          </div>

          <div className="flex items-center space-x-2">
            <input
              type="checkbox"
              id="includeApiData"
              checked={formData.includeApiData}
              onChange={(e) => setFormData({...formData, includeApiData: e.target.checked})}
              className="rounded"
            />
            <Label htmlFor="includeApiData">Include all API data in message</Label>
          </div>

          <div className="flex justify-between pt-4">
            <div>
              {telegramNode.id && (
                <Button 
                  variant="outline" 
                  onClick={() => {
                    if (window.confirm('Are you sure you want to delete this Telegram message node?')) {
                      // The delete handler will be passed down
                      if (onDelete) {
                        onDelete(); // Close modal first
                      }
                    }
                  }}
                  className="bg-red-600 hover:bg-red-700 text-white"
                >
                  <TrashIcon className="w-4 h-4 mr-2" />
                  Delete
                </Button>
              )}
            </div>
            <div className="flex space-x-2">
              <Button variant="outline" onClick={onCancel}>Cancel</Button>
              <Button onClick={() => onSave(formData)}>Save</Button>
            </div>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}

// Strategy Settings Editor Component
function StrategySettingsEditor({ 
  strategy, 
  onSave, 
  onCancel 
}: { 
  strategy: any; 
  onSave: (strategyData: any) => void; 
  onCancel: () => void;
}) {
  const [formData, setFormData] = useState(strategy);

  const handleSave = () => {
    // Ensure all required fields are present and properly formatted
    const cleanedData = {
      ...formData,
      // Trim whitespace and ensure proper formatting
      name: formData.name.trim(),
      description: formData.description?.trim() || undefined,
      cron: formData.cron?.trim() || undefined,
    };
    
    console.log('🔧 Saving strategy with data:', cleanedData);
    onSave(cleanedData);
  };

  return (
    <div className="fixed inset-0 z-60 bg-black/80 backdrop-blur-sm flex items-center justify-center p-4">
      <Card className="w-full max-w-3xl">
        <CardHeader>
          <CardTitle className="text-white">
            {strategy ? 'Edit Strategy' : 'New Strategy'}
          </CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="grid gap-4">
            <div>
              <Label htmlFor="name">Name</Label>
              <Input
                id="name"
                value={formData.name}
                onChange={(e) => setFormData({...formData, name: e.target.value})}
                placeholder="Strategy Name"
              />
            </div>
            <div>
              <Label htmlFor="description">Description</Label>
              <Textarea
                id="description"
                value={formData.description || ''}
                onChange={(e) => setFormData({...formData, description: e.target.value || undefined})}
                placeholder="Strategy Description"
                rows={3}
              />
            </div>
            <div className="flex items-center space-x-2 mb-4">
              <input
                type="checkbox"
                id="manualOnly"
                checked={formData.cron === null || formData.cron === ''}
                onChange={(e) => setFormData({...formData, cron: e.target.checked ? null : '*/5 * * * *'})}
                className="rounded"
              />
              <Label htmlFor="manualOnly">Manual execution only (no automatic schedule)</Label>
            </div>
            {formData.cron && (
              <div>
                <Label htmlFor="cron">Cron Expression</Label>
                <Input
                  id="cron"
                  value={formData.cron || ''}
                  onChange={(e) => setFormData({...formData, cron: e.target.value})}
                  placeholder="0 9 * * *"
                />
                <p className="text-xs text-gray-400 mt-1">
                  Format: minute hour day month weekday (e.g., "0 9 * * *" = 9 AM daily)
                </p>
              </div>
            )}
          </div>
          <div className="flex justify-end space-x-2 pt-4">
            <Button variant="outline" onClick={onCancel}>Cancel</Button>
            <Button onClick={() => handleSave()}>Save</Button>
          </div>
        </CardContent>
      </Card>
    </div>
  );
} 